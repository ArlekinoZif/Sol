---
назва: Десеріалізація Даних Програми  
завдання:  
- Пояснити Програмно Похідні Акаунти (PDA)  
- Отримати PDA на основі заданих seed  
- Отримати акаунти програми  
- Використовувати Borsh для десеріалізації користувацьких даних  
---

# Стислий виклад

- Програми зберігають дані в PDA, що означає **Програмно Похідна Адреса** (Program Derived Address).  
- PDA не мають відповідного секретного ключа.  
- Щоб зберігати та знаходити дані, необхідно отримати PDA за допомогою методу `findProgramAddress(seeds, programid)`.  
- Ви можете отримати акаунти, що належать програмі, використовуючи `getProgramAccounts(programId)`.  
- Дані акаунту потрібно десеріалізувати, використовуючи ту ж структуру, яка використовувалась для їх зберігання. Для цього можна використовувати `@coral-xyz/borsh` для створення схеми.

# Урок

У попередньому уроці ми серіалізували дані програми, які згодом були збережені в блокчейні програмою Solana. У цьому уроці ми детальніше розглянемо, як програми зберігають дані в блокчейні, як отримати ці дані та як десеріалізувати їх.

## Програми

Часто кажуть, що у Solana все є акаунтом. Навіть програми. Програми — це акаунти, які зберігають код і позначені як виконувані (executable). Цей код може бути виконаний на Solana за вказівкою. Адреса програми є публічним ключем на еліптичній кривій Ed25519. Як і всі публічні ключі, вони мають відповідні секретні ключі.

Програми зберігають дані окремо від свого коду. Дані програм зберігаються у **PDA (Program Derived Address)** — програмах, які використовують адреси, отримані з певних параметрів. PDA — це унікальне поняття для Solana, але шаблон цілком знайомий: 

- PDA можна уявити як сховище ключів і значень, де адреса є ключем, а дані всередині акаунту — значенням.  
- Також PDA можна розглядати як записи в базі даних, де адреса виступає як первинний ключ, який використовується для пошуку значень всередині.

PDA поєднують адресу програми та обрані розробником seeds (початкові значення) для створення адрес, які зберігають окремі частини даних. Оскільки PDA є адресами, що лежать **поза** еліптичною кривою Ed25519, вони не мають секретних ключів. Замість цього підпис від імені PDA може здійснювати програма, яка була використана для його створення.

PDA та дані всередині них можна стабільно знаходити на основі адреси програми, bump і seeds. Щоб знайти PDA, програмний ідентифікатор (program ID) і вибрані розробником seeds (наприклад, текстовий рядок) передаються через функцію [`findProgramAddress()`](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#findProgramAddress).  

Розгляньмо декілька прикладів...

#### Приклад: програма з глобальним станом  

Проста програма, яка має глобальний стан, наприклад, наш ping лічильник, може використовувати лише один PDA, заснований на простій seed-фразі, як-от `"GLOBAL_STATE"`. Якщо клієнт хоче читати дані з цього PDA, він може отримати адресу, використовуючи програмний ідентифікатор (program ID) та цей самий seed.

```typescript
const [pda, bump] = await findProgramAddress(Buffer.from("GLOBAL_STATE"), programId)
```

![Глобальний стан з використанням PDA](../../assets/pdas-global-state.svg)

#### Приклад: програма з даними користувача  

У програмах, які зберігають дані користувача, зазвичай використовується публічний ключ користувача як seed. Це розділяє дані кожного користувача у власний PDA. Таке розділення дозволяє клієнту знайти дані кожного користувача, визначивши адресу за допомогою програмного ідентифікатора (program ID) і публічного ключа користувача.

```typescript
const [pda, bump] = await web3.PublicKey.findProgramAddress(
  [
    publicKey.toBuffer()
  ],
  programId
)
```

![Стан для кожного користувача](../../assets/pdas-per-user-state.svg)
### Приклад: програма з кількома елементами даних на одного користувача  

Якщо у користувача є кілька елементів даних, програма може використовувати більше seed для створення та ідентифікації облікових записів. Наприклад, у додатку для ведення нотаток може бути один обліковий запис на кожну нотатку, де кожен PDA визначається за допомогою публічного ключа користувача та назви нотатки.

```typescript
const [pda, bump] = await web3.PublicKey.findProgramAddress(
  [
    publicKey.toBuffer(), 
    Buffer.from("Shopping list")
  ],
  programId,
);
```

![Глобальний стан з використанням PDA](../../assets/pdas-note-taking-program.svg)

У цьому прикладі ми бачимо, що і в Еліс, і в Боба є нотатка з назвою 'Shopping List' (Список покупок), але завдяки використанню їхніх адрес гаманців як одного з seed, обидві ці нотатки можуть існувати одночасно.

### Отримання кількох акаунтів

Окрім обчислення адрес, ви можете отримати всі акаунти, створені програмою, за допомогою методу `connection.getProgramAccounts(programId)`. Цей метод повертає масив об'єктів, де кожен об'єкт має властивість `pubkey`, яка представляє публічний ключ акаунту, і властивість `account` типу `AccountInfo`. Ви можете використовувати властивість `account` для отримання даних акаунту.

```typescript
const accounts = connection.getProgramAccounts(programId).then(accounts => {
  accounts.map(({ pubkey, account }) => {
    console.log('Account:', pubkey)
    console.log('Data buffer:', account.data)
  })
})
```

## Десеріалізація даних програми

Атрибут `data` в об'єкті `AccountInfo` є буфером. Щоб ефективно його використовувати, необхідно написати код, який десеріалізує ці дані у більш зручний для роботи формат. Це схоже на процес серіалізації, який ми розглядали у попередньому уроці. Як і раніше, ми будемо використовувати [Borsh](https://borsh.io/) та пакет `@coral-xyz/borsh`. Якщо вам потрібно пригадати ці інструменти, перегляньте попередній урок.

Для десеріалізації потрібно заздалегідь знати структуру акаунту. Створюючи власні програми, ви визначаєте, як це буде зроблено в процесі розробки. Багато програм також мають документацію про те, як десеріалізувати дані акаунта. В іншому випадку, якщо код програми доступний, ви можете переглянути джерело і визначити структуру даних таким чином.

Щоб правильно десеріалізувати дані з ончейн-програми, необхідно створити схему на стороні клієнта, яка відображає, як дані зберігаються в акаунті. Наприклад, нижче наведена можлива схема для акаунту, що зберігає метадані про гравця в ончейн-грі. 

```typescript
import * as borsh from "@coral-xyz/borsh";

borshAccountSchema = borsh.struct([
  borsh.bool("initialized"),
  borsh.u16("playerId"),
  borsh.str("name"),
]);

```

Як тільки ви визначили свою схему, просто викличте `.decode(buffer)` на схемі.

```typescript
import * as borsh from "@coral-xyz/borsh";

borshAccountSchema = borsh.struct([
  borsh.bool("initialized"),
  borsh.u16("playerId"),
  borsh.str("name"),
]);

const { playerId, name } = borshAccountSchema.decode(buffer);

```

# Лабораторна робота

Давайте разом попрактикуємося, використовуючи додаток Movie Review з останнього уроку. Не хвилюйтеся, якщо ви тільки зараз приєдналися до цього уроку — ви все одно зможете слідкувати за поясненнями.

Нагадаю, цей проект використовує програму Solana, розгорнуту на Devnet, яка дозволяє користувачам залишати відгуки про фільми. У минулому уроці ми додали функціональність до каркасу інтерфейсу, дозволяючи користувачам подавати відгуки про фільми, але список відгуків все ще показує фіктивні дані. Давайте виправимо це, отримавши акаунти програми та десеріалізувавши дані, що зберігаються там.

![фронтенд для рецензій на фільми](../assets/movie-reviews-frontend.png)

### 1. Завантажте початковий код

Якщо ви не завершили лабораторну роботу з минулого уроку або хочете переконатися, що нічого не пропустили, ви можете завантажити [початковий код](https://github.com/Unboxed-Software/solana-movie-frontend/tree/solution-serialize-instruction-data).

Проект є досить простою Next.js‑програмою. Він містить `WalletContextProvider`, який ми створили в уроці про гаманці, компонент `Card` для відображення рецензії на фільм, компонент `MovieList` для показу рецензій у вигляді списку, компонент `Form` для надсилання нової рецензії та файл `Movie.ts`, що містить визначення класу об’єкта `Movie`.

Зверніть увагу, що коли ви запускаєте команду `npm run dev`, відгуки, що відображаються на сторінці, є фіктивними. Згодом ми замінимо їх на справжні дані.

### 2. Створення буферної структури

Пам'ятайте, що для правильної взаємодії з програмою Solana, вам потрібно знати, як її дані структуровані. Нагадуємо:

![Крива Ed25519 з Movie Review Program](../assets/movie-review-program.svg)

Дані програми (частини, що виконується) зберігаються в програмному акаунті, але окремі відгуки зберігаються в PDA. Ми використовуємо `findProgramAddress()`, щоб створити PDA, унікальний для кожного гаманця та кожного фільму. Ми збережемо наступні дані в `data` акаунту PDA:

1. `initialized` як булеве значення, що вказує, чи був ініціалізований акаунт.
2. `rating` як беззнакове 8-бітне ціле число, що представляє оцінку фільму, поставлену рецензентом (від 1 до 5).
3. `title` як рядок, що представляє назву рецензованого фільму.
4. `description` як рядок, що містить текстову частину рецензії.

Налаштуємо схему `borsh` в класі `Movie`, щоб представити структуру даних акаунту фільму. Почнемо з імпорту `@coral-xyz/borsh`. Далі створимо статичну властивість `borshAccountSchema` та налаштуємо її на відповідну структуру `borsh`, що містить зазначені вище властивості.

```tsx
import * as borsh from '@coral-xyz/borsh'

export class Movie {
  title: string;
  rating: number;
  description: string;

  ...

  static borshAccountSchema = borsh.struct([
    borsh.bool('initialized'),
    borsh.u8('rating'),
    borsh.str('title'),
    borsh.str('description'),
  ])
}
```

Пам'ятайте, що порядок тут *має значення*. Він має співпадати з тим, як структуровані дані акаунту.
### 3. Створіть метод для десеріалізації даних

Тепер, коли ми налаштували структуру буфера, давайте створимо статичний метод в класі `Movie` під назвою `deserialize`, який прийматиме необов'язковий параметр `Buffer` і повертатиме об'єкт `Movie` або `null`.

```typescript
import * as borsh from '@coral-xyz/borsh'

export class Movie {
  title: string;
  rating: number;
  description: string;

  ...

  static borshAccountSchema = borsh.struct([
    borsh.bool('initialized'),
    borsh.u8('rating'),
    borsh.str('title'),
    borsh.str('description'),
  ])

  static deserialize(buffer?: Buffer): Movie|null {
    if (!buffer) {
      return null
    }

    try {
      const { title, rating, description } = this.borshAccountSchema.decode(buffer)
      return new Movie(title, rating, description)
    } catch(error) {
      console.log('Deserialization error:', error)
      return null
    }
  }
}
```

Метод спочатку перевіряє, чи існує буфер, і повертає `null`, якщо його немає. Далі він використовує створену структуру для декодування буфера, а потім використовує ці дані для створення та повернення екземпляра класу `Movie`. Якщо декодування не вдається, метод виводить помилку в консоль і повертає `null`.

### 4. Отримати акаунти

Тепер, коли ми налаштували десеріалізацію даних акаунтів, нам потрібно фактично отримати ці акаунти. Відкрийте файл `MovieList.tsx` і імпортуйте `@solana/web3.js`. Потім створіть нове з'єднання `Connection` всередині компонента `MovieList`. Нарешті, замініть рядок `setMovies(Movie.mocks)` всередині хука `useEffect` на виклик `connection.getProgramAccounts`. Отриманий масив перетворіть на масив фільмів і викликайте `setMovies`, щоб оновити стан.

```tsx
import { Card } from './Card'
import { FC, useEffect, useState } from 'react'
import { Movie } from '../models/Movie'
import * as web3 from '@solana/web3.js'
import { useConnection } from "@solana/wallet-adapter-react"

const MOVIE_REVIEW_PROGRAM_ID = 'CenYq6bDRB7p73EjsPEpiYN7uveyPUTdXkDkgUduboaN'

export const MovieList: FC = () => {
  const { connection } = useConnection()
  const [movies, setMovies] = useState<Movie[]>([])

  useEffect(() => {
    connection.getProgramAccounts(new web3.PublicKey(MOVIE_REVIEW_PROGRAM_ID)).then(async (accounts) => {
      const movies: Movie[] = accounts.map(({ account }) => {
        return Movie.deserialize(account.data)
      })

      setMovies(movies)
    })
  }, [])

  return (
    <div>
      {
        movies.map((movie, i) => <Card key={i} movie={movie} /> )
      }
    </div>
  )
}
```

На цьому етапі ви повинні мати можливість запустити додаток і побачити список відгуків про фільми, отриманих з програми!

Залежно від кількості надісланих рецензій, завантаження може тривати довго або спричинити підвисання браузера. Але не хвилюйтеся — у наступному уроці ми навчимося здійснювати посторінкове завантаження та фільтрацію акаунтів, щоб ви могли більш вибірково керувати тим, що саме завантажується.

Якщо вам потрібно більше часу для роботи з цим проектом, щоб комфортно освоїти ці концепції, ознайомтеся з [кодом рішення](https://github.com/Unboxed-Software/solana-movie-frontend/tree/solution-deserialize-account-data), перш ніж продовжити.

# Завдання

Тепер ваша черга побудувати щось самостійно. У минулому уроці ви працювали над програмою Student Intros, щоб серіалізувати дані інструкцій та надіслати нову презентацію в мережу. Тепер настав час отримати та десеріалізувати дані акаунтів програми. Пам'ятайте, що Solana програма, яка підтримує це, знаходиться за адресою `HdE95RSVsdb315jfJtaykXhXY478h53X6okDupVfY9yf`.

![Student Intros фронтенд](../assets/student-intros-frontend.png)

1. Ви можете побудувати це з нуля або завантажити [початковий код](https://github.com/Unboxed-Software/solana-student-intros-frontend/tree/solution-serialize-instruction-data).
2. Створіть структуру буфера акаунту в файлі `StudentIntro.ts`. Дані акаунту містять:
   1. `initialized` як беззнакове 8-бітне ціле число, що вказує, яку інструкцію виконати (повинно бути 1).
   2. `name` як рядок, що представляє ім'я студента.
   3. `message` як рядок, що представляє повідомлення студента про свій досвід роботи з Solana.
3. Створіть статичний метод у файлі `StudentIntro.ts`, який за допомогою структури буфера десеріалізує буфер даних акаунту в об'єкт `StudentIntro`.
4. У компоненті `StudentIntroList` в `useEffect` отримайте акаунти програми та десеріалізуйте їхні дані у список об'єктів `StudentIntro`.
5. Замість імітованих даних тепер ви повинні побачити студентські введення з мережі!

Якщо ви застрягли, не соромтесь [перевірити код рішення](https://github.com/Unboxed-Software/solana-student-intros-frontend/tree/solution-deserialize-account-data).

Як завжди, будьте креативними з цими завданнями і розвивайте їх далі, якщо хочете!


## Завершили лабораторну роботу?

Завантажте свій код на GitHub і [поділіться своїми враженнями від цього уроку](https://form.typeform.com/to/IPH0UGz7#answers-lesson=9cb89e09-2c97-4185-93b0-c89f7aca7677)!
