---
назва: Стиснуті NFT
завдання:
- Створити колекцію стиснутих NFT за допомогою програми Bubblegum від Metaplex
- Мінт стиснених NFT за допомогою Bubblegum TS SDK
- Передача стиснених NFT за допомогою Bubblegum TS SDK
- Читання стиснених NFT-даних за допомогою Read API
---

# Стислий виклад

- **Стиснені NFT (cNFTs)** використовують **Стиснення Стану (State Compression)** для хешування даних NFT та зберігання хешу ончейн в акаунті, використовуючи структуру **одночасного дерева Меркла**.
- Хеш даних cNFT не може бути використаний для виведення даних cNFT, але він може бути використаний для **перевірки**, чи правильні ті дані cNFT, які ви бачите
- Підтримка RPC-провайдерів **індексує** дані cNFT офчейн при створенні cNFT, щоб ви могли використовувати **Read API** для доступу до даних
- Програма **Metaplex Bubblegum** - це абстракція над програмою **State Compression**, яка дозволяє вам простіше створювати, мінтити та керувати колекціями cNFT

# Урок

Стиснені NFT (cNFTs) — це саме те, що випливає з їхньої назви: NFT, структура яких займає менше місця в акаунті порівняно з традиційними NFT. Стиснені NFT використовують концепцію **Стиснення Стану** для зберігання даних у спосіб, що суттєво знижує витрати.

Транзакційні витрати в Solana настільки низькі, що більшість користувачів навіть не замислюються, наскільки дорогим може бути мінт NFT у великих масштабах. Вартість створення та мінта 1 мільйона традиційних NFT становить приблизно 24 000 SOL. Для порівняння, cNFT можуть бути структуровані так, що такий самий процес коштуватиме 10 SOL або навіть менше. Це означає, що використання cNFT замість традиційних NFT дозволяє знизити витрати більш ніж у 1000 разів.

Однак працювати з cNFT може бути непросто. З часом інструменти для роботи з ними стануть достатньо абстрагованими від базової технології, тож різниця у взаємодії між традиційними NFT і cNFT буде мінімальною. Але поки що вам доведеться розбиратися з базовими технічними аспектами, тож давайте зануримося у процес!

## Теоретичний огляд cNFT

Більшість витрат, пов’язаних із традиційними NFT, зумовлені використанням місця для зберігання акаунтів. Стиснені NFT застосовують концепцію **стиснення стану**, щоб зберігати дані у дешевшому **стані реєстру** блокчейну, а дорожчий простір акаунту використовують лише для збереження «відбитка» або **хешу** даних. Цей хеш дозволяє криптографічно перевірити, що дані не були змінені.

Для зберігання хешів та перевірки ми використовуємо спеціальну структуру бінарного дерева, відому як **concurrent Merkle tree (одночасне дерево Меркла)**. Ця деревоподібна структура дозволяє нам хешувати дані разом у детермінований спосіб, щоб обчислити єдиний остаточний хеш, який зберігається ончейн. Цей кінцевий хеш значно менший за розміром, ніж всі вихідні дані разом узяті, звідси і «стиснення». Етапи цього процесу наступні:

1. Взяти будь-який набір даних  
2. Створити хеш цих даних  
3. Зберегти цей хеш як «листок» у нижній частині дерева  
4. Кожну пару листків захешувати разом, утворюючи «гілку»  
5. Кожну пару гілок також хешувати між собою  
6. Продовжувати підійматися деревом, хешуючи сусідні гілки  
7. На вершині дерева утворюється фінальний **кореневий хеш**  
8. Зберегти кореневий хеш ончейн як доказ достовірності даних у кожному листку  
9. Будь-хто, хто хоче перевірити, чи їхні дані відповідають «джерелу істини», може повторити цей процес і порівняти фінальний хеш без необхідності зберігати всі дані ончейн
    
Одна з проблем, не розглянутих вище, — як зробити дані доступними, якщо їх не можна отримати з акаунту. Оскільки процес хешування відбувається ончейн, усі дані зберігаються в стані реєстру й теоретично можуть бути відновлені з початкової транзакції шляхом відтворення всього стану блокчейну з моменту його створення. Однак набагато простіше (хоча все ще складно) використовувати **індексатор**, який відстежуватиме та індексуватиме ці дані під час виконання транзакцій. Це забезпечує наявність офчейн «кешу» даних, до якого будь-хто може отримати доступ і перевірити їхню відповідність ончейн кореневому хешу.

Цей процес *дуже складний*. Нижче ми розглянемо основні концепції, але не хвилюйтеся, якщо не зрозумієте все відразу. У уроці про стискання стану ми детальніше розглянемо теорію, а тут зосередимося на тому, як це застосовується до NFT. Наприкінці цього уроку ви зможете працювати з cNFT, навіть якщо не повністю розумієте всі деталі стискання стану.

### Одночасні дерева Меркла

Дерево Меркла - це бінарна деревоподібна структура, представлена одним хешем. Кожен вузол листка в структурі є хешем своїх внутрішніх даних, а кожна гілка - хешем хешів своїх дочірніх листків. У свою чергу, гілки також хешуються разом, поки врешті-решт не залишиться один остаточний кореневий хеш.

Будь-яка модифікація даних листків змінює кореневий хеш. Це спричиняє проблему, коли декілька транзакцій в одному слоті намагаються змінити дані листків. Оскільки ці транзакції повинні виконуватися послідовно, всі, крім першої, зазнають невдачі, оскільки кореневий хеш і доказ, переданий першою транзакцією, буде визнано недійсним.

**Одночасне дерево Меркла** — це дерево Меркла, яке зберігає безпечний журнал змін разом із їхнім кореневим хешем і доказом для його отримання. Коли кілька транзакцій у тому самому слоті намагаються змінити дані листків, цей журнал змін слугує джерелом істини, що дозволяє одночасно вносити зміни до дерева.

При роботі з одночасним деревом Меркла є три змінні, які визначають розмір дерева, вартість створення дерева і кількість одночасних змін, які можуть бути зроблені в дереві:

1. Максимальна глибина
2. Максимальний розмір буфера
3. Глибина крони

**Максимальна глибина** — це найбільша кількість рівнів у дереві від листка до кореня. Оскільки дерева Меркла є бінарними, кожен рівень має вдвічі менше нод, ніж попередній. Тому за значенням глибини можна обчислити загальну кількість нод у дереві за формулою `2 ^ maxDepth`.

**Максимальний розмір буфера** - це фактично максимальна кількість одночасних змін, які ви можете зробити у дереві в межах одного слоту, при цьому кореневий хеш все ще буде дійсним.

**Глибина крони** — це кількість доказових нод, які зберігаються ончейн для певного шляху доказу. Щоб перевірити будь-який листок, потрібен повний шлях доказу для дерева. Цей шлях складається з однієї доказової ноди на кожен рівень дерева. Тобто, якщо максимальна глибина дерева становить 14, то шлях доказу міститиме 14 докозавих нод. Кожна така нода додає 32 байти до транзакції, тому для великих дерев розмір транзакції швидко перевищив би допустимий ліміт, якби доказові ноди не кешувалися ончейн.

Кожне з цих трьох значень, максимальна глибина, максимальний розмір буфера і глибина крони, має певний компроміс. Збільшення будь-якого з цих значень збільшує розмір акаунту, який використовується для зберігання дерева, таким чином збільшуючи вартість створення дерева. 

Вибір максимальної глибини досить простий, оскільки він безпосередньо пов'язаний з кількістю листків і, отже, з кількістю даних, які ви можете зберігати. Якщо вам потрібно 1 мільйон cNFT для одного дерева, знайдіть максимальну глибину, при якій виконується наступний вираз: `2^maxDepth > 1million`. Відповідь: 20.

Вибір максимального розміру буфера - це фактично питання пропускної здатності: скільки одночасних записів вам потрібно.

### Програми стиснення стану SPL і Noop

Програма стиснення стану SPL існує для того, щоб зробити вищезгаданий процес повторюваним і комбінованим у всій екосистемі Solana. Вона надає інструкції для ініціалізації дерев Меркла, керування листям дерев (тобто додавання, оновлення, видалення даних) та перевірки даних про листя.

Програма стиснення стану (State Compression Program) також використовує окрему програму "no op" (без операцій), основною метою якої є спрощення індексації даних листів шляхом запису їх до стану реєстру.

### Використання Стану Реєстру для зберігання

Реєстр Solana — це список записів, які містять підписані транзакції. Теоретично, він може бути простежений аж до початкового блоку (genesis block). Це означає, що будь-які дані, які коли-небудь були включені до транзакції, залишаються в реєстрі.

Коли ви хочете зберігати стиснені дані, ви передаєте їх до програми стиснення стану (State Compression program), де вони хешуються та надсилаються як "подія" до програми Noop. Потім хеш зберігається у відповідному паралельному дереві Меркла (concurrent Merkle tree). Оскільки дані проходять через транзакцію та навіть зберігаються в логах програми Noop, вони назавжди залишаються у стані реєстру.

### Індексуйте дані для легкого пошуку

За звичайних умов ви зазвичай отримуєте доступ до даних в блокчейні, вибравши відповідний акаунт. Однак при використанні стиснення все не так просто. 

Як згадувалося вище, дані тепер існують у стані реєстру, а не в акаунті. Найпростіше знайти повні дані в журналах інструкції Noop, але хоча ці дані в певному сенсі будуть існувати в стані реєстру завжди, вони, ймовірно, будуть недоступні через валідатори через певний проміжок часу.

Щоб заощадити місце та підвищити продуктивність, валідатори не зберігають усі транзакції аж до генезисного блоку. Тривалість доступу до логів інструкції Noop, пов’язаних із вашими даними, залежить від конкретного валідатора, але зрештою цей доступ буде втрачено, якщо ви покладаєтеся безпосередньо на логи інструкцій.

Технічно ви *можете* відтворити стан транзакцій аж до генезисного блоку, але середньостатистична команда цього не робитиме, і це точно не буде ефективним. Натомість слід використовувати індексатор, який спостерігатиме за подіями, надісланими до програми Noop, і зберігатиме відповідні дані поза мережею. Таким чином, вам не доведеться турбуватися про втрату доступу до старих даних.

## Створення колекції cNFT

Після теоретичного огляду перейдемо до основної частини цього уроку: створення колекції cNFT.

На щастя, ви можете скористатися інструментами, створеними Solana Foundation, спільнотою розробників Solana та Metaplex, щоб спростити цей процес. Зокрема, ми використовуватимемо SDK `@solana/spl-account-compression`, програму Metaplex Bubblegum і відповідний TS SDK програми Bubblegum — `@metaplex-foundation/mpl-bubblegum`.

<aside>
💡 На момент написання команда Metaplex переходить на новий клієнтський SDK для Bubblegum, який підтримує umi — їхній модульний фреймворк для створення та використання JS-клієнтів для програм Solana. У цьому уроці ми не використовуватимемо версію SDK з umi. Натомість ми жорстко зафіксуємо нашу залежність на версії 0.7 (`@metaplex-foundation/mpl-bubblegum@0.7`). Ця версія надає прості допоміжні функції для створення інструкцій Bubblegum.

</aside>

### Підготуйте метадані

Перед початком вам потрібно підготувати метадані для ваших NFT так само, як ви б це робили при використанні Candy Machine. По суті, NFT — це просто токен із метаданими, які відповідають стандарту NFT. Іншими словами, вони мають виглядати приблизно так:

```json
{
  "name": "12_217_47",
  "symbol": "RGB",
  "description": "Random RGB Color",
  "seller_fee_basis_points": 0,
  "image": "https://raw.githubusercontent.com/ZYJLiu/rgb-png-generator/master/assets/12_217_47/12_217_47.png",
  "attributes": [
    {
      "trait_type": "R",
      "value": "12"
    },
    {
      "trait_type": "G",
      "value": "217"
    },
    {
      "trait_type": "B",
      "value": "47"
    }
  ]
}
```

Залежно від вашого випадку використання, ви можете генерувати це динамічно або підготувати JSON-файл для кожного cNFT заздалегідь. Вам також знадобляться всі інші ресурси, на які посилається JSON, наприклад, URL зображення `image`, як показано в наведеному вище прикладі.

### Створення NFT колекції

Якщо ви хочете, щоб ваші cNFT стали частиною колекції, вам потрібно створити NFT колекцію **до** того, як ви почнете мінтити cNFT. Це традиційний NFT, який діє як посилання, що зв'язує ваші cNFT в єдину колекцію. Ви можете створити цей NFT за допомогою бібліотеки `@metaplex-foundation/js`. Просто переконайтеся, що ви встановили `isCollection` у значення `true`. 

```tsx
const collectionNft = await metaplex.nfts().create({
    uri: someUri,
    name: "Collection NFT",
    sellerFeeBasisPoints: 0,
    updateAuthority: somePublicKey,
    mintAuthority: somePublicKey,
    tokenStandard: 0,
    symbol: "Collection",
    isMutable: true,
    isCollection: true,
})
```

### Створення акаунту дерева Меркла

Тепер ми починаємо відхилятися від процесу, який ви використовуєте при створенні традиційних NFT. Механізм ончейн-сховища, який ви використовуєте для стиснення станів, - це акаунт, що представляє одночасне дерево Меркла. Цей акаунт дерева Меркла належить програмі стиснення станів SPL. Перш ніж ви зможете робити щось, пов'язане з cNFT, вам потрібно створити порожній акаунт дерева Меркла відповідного розміру.

Змінними, що впливають на розмір акаунту, є:

1. Максимальна глибина (Max depth) 
2. Максимальний розмір буфера (Max buffer size) 
3. Глибина крони (Canopy depth)

Перші дві змінні необхідно вибрати з існуючого набору допустимих пар. У таблиці нижче наведено допустимі пари, а також кількість cNFT, які можна створити з цими значеннями.

| Max Depth | Max Buffer Size | Max Number of cNFTs |
| --- | --- | --- |
| 3 | 8 | 8 |
| 5 | 8 | 32 |
| 14 | 64 | 16,384 |
| 14 | 256 | 16,384 |
| 14 | 1,024 | 16,384 |
| 14 | 2,048 | 16,384 |
| 15 | 64 | 32,768 |
| 16 | 64 | 65,536 |
| 17 | 64 | 131,072 |
| 18 | 64 | 262,144 |
| 19 | 64 | 524,288 |
| 20 | 64 | 1,048,576 |
| 20 | 256 | 1,048,576 |
| 20 | 1,024 | 1,048,576 |
| 20 | 2,048 | 1,048,576 |
| 24 | 64 | 16,777,216 |
| 24 | 256 | 16,777,216 |
| 24 | 512 | 16,777,216 |
| 24 | 1,024 | 16,777,216 |
| 24 | 2,048 | 16,777,216 |
| 26 | 512 | 67,108,864 |
| 26 | 1,024 | 67,108,864 |
| 26 | 2,048 | 67,108,864 |
| 30 | 512 | 1,073,741,824 |
| 30 | 1,024 | 1,073,741,824 |
| 30 | 2,048 | 1,073,741,824 |

Зверніть увагу, що кількість cNFTs, які можна зберігати у дереві, повністю залежить від максимальної глибини, тоді як розмір буфера визначає кількість одночасних змін (мінтів, трансферів тощо), які можуть відбутися в дереві в тому самому слоті. Іншими словами, виберіть максимальну глибину, яка відповідає кількості NFT, які ви хочете зберігати у дереві, а потім оберіть одну з доступних опцій для максимального розміру буфера, виходячи з очікуваного рівня трафіку.

Далі оберіть глибину крони. Збільшення глибини крони підвищує композиційність ваших cNFT. Щоразу, коли ваш код або код іншого розробника намагатиметься перевірити cNFT, доведеться передавати стільки доказових нод, скільки є «шарів» у вашому дереві. Наприклад, для дерева з максимальною глибиною 20 потрібно буде передавати 20 доказових вузлів. Це не лише ускладнює процес, але й створює ризик перевищення розміру транзакції, оскільки кожна доказова нода займає 32 байти.

Наприклад, якщо у вашому дереві дуже мала глибина крони, NFT-маркетплейс може підтримувати лише прості перекази NFT, але не зможе реалізувати функції на кшталт ончейн-системи ставок для ваших cNFT. Крона фактично кешує доказові ноди ончейн, тож вам не потрібно передавати їх усі в транзакції, що дозволяє проводити більш складні операції.

Збільшення будь-якого з цих трьох параметрів збільшує розмір акаунта, а отже, і вартість його створення. Зважуйте переваги відповідно до ваших потреб при виборі значень.

Коли ви визначитеся з цими параметрами, ви можете використати допоміжну функцію `createAllocTreeIx` з TS SDK пакету `@solana/spl-account-compression`, щоб створити інструкцію для створення порожнього акаунту.

```tsx
import { createAllocTreeIx } from "@solana/spl-account-compression"

const treeKeypair = Keypair.generate()

const allocTreeIx = await createAllocTreeIx(
  connection,
  treeKeypair.publicKey,
  payer.publicKey,
  { maxDepth: 20; maxBufferSize: 256 },
  canopyDepth
)
```

Зверніть увагу, що це лише допоміжна функція для розрахунку необхідного розміру акаунту та створення інструкції, яку потрібно надіслати до System Program для виділення акаунту. Ця функція поки що не взаємодіє з жодними програмами, пов’язаними зі стисненням.

### Використання Bubblegum для ініціалізації вашого дерева

Після створення акаунту для порожнього дерева ви можете використати програму Bubblegum для його ініціалізації. Окрім акаунту дерева Меркла, Bubblegum створює акаунт конфігурації дерева, щоб додати функціонал і трекінг для cNFT.

Версія 0.7 TypeScript SDK `@metaplex-foundation/mpl-bubblegum` надає допоміжну функцію `createCreateTreeInstruction`, яка використовується для виклику інструкції `create_tree` у програмі Bubblegum. Під час виклику цієї функції необхідно отримати `treeAuthority` PDA (програмно визначений акаунт), який очікує програма. Цей PDA генерується з використанням адреси дерева як seed.

```tsx
import {
	createAllocTreeIx,
	SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
  SPL_NOOP_PROGRAM_ID,
} from "@solana/spl-account-compression"
import {
  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,
  createCreateTreeInstruction,
} from "@metaplex-foundation/mpl-bubblegum"

...

const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(
  [treeKeypair.publicKey.toBuffer()],
  BUBBLEGUM_PROGRAM_ID
)

const createTreeIx = createCreateTreeInstruction(
  {
    treeAuthority,
    merkleTree: treeKeypair.publicKey,
    payer: payer.publicKey,
    treeCreator: payer.publicKey,
    logWrapper: SPL_NOOP_PROGRAM_ID,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
  },
  {
    maxBufferSize: 256,
    maxDepth: 20,
    public: false,
  },
  BUBBLEGUM_PROGRAM_ID
)
```

Нижче наведено список необхідних вхідних даних для цієї допоміжної функції:

- `accounts` - Об'єкт, що представляє акаунти, потрібні для інструкції. Він включає:
    - `treeAuthority` - Bubblegum очікує, що це буде PDA (програмно визначений акаунт), створений з використанням адреси дерева Меркла як seed
    - `merkleTree` - Акаунт дерева Меркла
    - `payer` - Адреса, яка сплачує комісії за транзакцію, оренду тощо
    - `treeCreator` - Адреса, яка буде вказана як творець дерева
    - `logWrapper` - Програма, яка використовується для передачі даних індексаторам через логи; це має бути адреса програми SPL Noop, якщо у вас немає іншого кастомного рішення
    - `compressionProgram` - Програма компресії, яка використовується для ініціалізації дерева Меркла; це має бути адреса програми SPL State Compression, якщо у вас немає іншого кастомного рішення
- `args` - Об'єкт, що представляє додаткові аргументи, потрібні для інструкції. Він включає:
    - `maxBufferSize` - Максимальний розмір буфера дерева Меркла
    - `maxDepth` - Максимальна глибина дерева Меркла
    - `public` - Якщо встановлено значення `true`, будь-хто зможе створювати cNFT у цьому дереві; якщо встановлено значення `false`, тільки творець дерева або делегат дерева зможе створювати cNFT

Після подання це викличе інструкцію `create_tree` у програмі Bubblegum. Ця інструкція виконує три дії:

1. Створює акаунт PDA для конфігурації дерева.
2. Ініціалізує акаунт конфігурації дерева з відповідними початковими значеннями.
3. Виконує Міжпрограмний виклик (CPI) до програми стиснення стану для ініціалізації порожнього акаунту дерева Меркла.

Ви можете переглянути код програми [тут](https://github.com/metaplex-foundation/mpl-bubblegum/blob/main/programs/bubblegum/program/src/lib.rs#L887).

### Мінт cNFTs

Коли акаунт дерева Меркла та відповідний акаунт конфігурації Bubblegum налаштовані, можна створювати cNFT у цьому дереві. Для цього потрібно використовувати одну з інструкцій Bubblegum: `mint_v1` або `mint_to_collection_v1`, залежно від того, чи хочете ви, щоб випущений cNFT був частиною колекції.

Версія 0.7 TS SDK `@metaplex-foundation/mpl-bubblegum` надає допоміжні функції `createMintV1Instruction` і `createMintToCollectionV1Instruction`, щоб спростити створення цих інструкцій.

Обидві функції потребують передачі метаданих NFT та списку акаунтів, необхідних для мінта cNFT. Нижче наведено приклад мінта у колекцію:

```tsx
const mintWithCollectionIx = createMintToCollectionV1Instruction(
  {
    payer: payer.publicKey,
    merkleTree: treeAddress,
    treeAuthority,
    treeDelegate: payer.publicKey,
    leafOwner: destination,
    leafDelegate: destination,
    collectionAuthority: payer.publicKey,
    collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,
    collectionMint: collectionDetails.mint,
    collectionMetadata: collectionDetails.metadata,
    editionAccount: collectionDetails.masterEditionAccount,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    logWrapper: SPL_NOOP_PROGRAM_ID,
    bubblegumSigner,
    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
  },
  {
    metadataArgs: Object.assign(nftMetadata, {
      collection: { key: collectionDetails.mint, verified: false },
    }),
  }
)
```

Зверніть увагу, що допоміжна функція має два аргументи: `accounts` і `args`. Параметр `args` — це просто метадані NFT, тоді як `accounts` — це об'єкт, який містить список акаунтів, необхідних для виконання інструкції. Слід визнати, що їх досить багато:

- `payer` — акаунт, що оплачуватиме комісії за транзакцію, оренду тощо
- `merkleTree` — акаунт дерева Меркла
- `treeAuthority` — уповноважений акаунт дерева; має бути тим самим PDA, який ви отримали раніше
- `treeDelegate` — делегат дерева; зазвичай це той самий акаунт, що й творець дерева
- `leafOwner` — призначений власник стисненого NFT, що мінтиться
- `leafDelegate` — призначений делегат стисненого NFT, що мінтиться; зазвичай це той самий акаунт, що й власник листка (leaf)
- `collectionAuthority` — уповноважений акаунт колекції NFT
- `collectionAuthorityRecordPda` — опційний запис уповноваженого акаунту колекції PDA; зазвичай його немає, у такому випадку слід вказати адресу програми Bubblegum
- `collectionMint` — мінт-акаунт для колекції NFT
- `collectionMetadata` — акаунт метаданих для колекції NFT
- `editionAccount` — акаунт головного видання колекції NFT
- `compressionProgram` — програма для стиснення; має бути адресою програми SPL State Compression, якщо у вас немає кастомного рішення
- `logWrapper` — програма для передачі даних у логах для індексаторів; має бути адресою програми SPL Noop, якщо у вас немає власного рішення 
- `bubblegumSigner` — PDA, який використовує програма Bubblegum для перевірки колекції
- `tokenMetadataProgram` — програма метаданих токенів, яка використовувалася для колекції NFT; зазвичай це програма Metaplex Token Metadata  

Мінт без колекції вимагає менше акаунтів, жоден з яких не є ексклюзивним для мінта без колекції. Ви можете подивитись приклад нижче.

```tsx
const mintWithoutCollectionIx = createMintV1Instruction(
  {
    payer: payer.publicKey,
    merkleTree: treeAddress,
    treeAuthority,
    treeDelegate: payer.publicKey,
    leafOwner: destination,
    leafDelegate: destination,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    logWrapper: SPL_NOOP_PROGRAM_ID,
  },
  {
    message: nftMetadata,
  }
)
```

## Взаємодія з cNFTs

Важливо зазначити, що cNFT не є токенами SPL. Це означає, що вашому коду необхідно дотримуватися інших конвенцій для обробки функціональності cNFT, такої як отримання, запит, передача тощо.

### Отримання даних cNFT 

Найпростіший спосіб отримати дані про існуючий cNFT — це використовувати [Read API стандарту цифрових активів](https://docs.solana.com/developing/guides/compressed-nfts#reading-compressed-nfts-metadata) (Read API). Зверніть увагу, що це окремо від стандартного JSON RPC. Для використання Read API вам потрібно використовувати підтримуваного RPC-постачальника. Metaplex підтримує (ймовірно, не вичерпний) [список RPC постачальників](https://developers.metaplex.com/bubblegum/rpcs), які підтримують Read API. У цьому уроці ми будемо використовувати [Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), оскільки вони надають безкоштовну підтримку для Devnet.

Щоб використовувати Read API для отримання конкретного cNFT, вам потрібно знати його asset ID. Однак після створення cNFT ви матимете максимум дві види інформації:

1. Підпис транзакції  
2. Індекс листка (leaf) (можливо)

Єдина справжня гарантія — це підпис транзакції. **Можливо** знайти індекс листка на його основі, але це вимагає складного парсингу. Коротко кажучи, потрібно отримати відповідні логи інструкцій з програми Noop і зпарсити їх, щоб знайти індекс листа. Ми детально розглянемо це в майбутньому уроці. На даний момент припустимо, що ви знаєте індекс листа.

Це розумне припущення для більшості мінтів, оскільки мінт буде контролюватися вашим кодом, і можна налаштувати його так, щоб ваш код міг відслідковувати, який індекс буде використовуватися кожного разу. Тобто, перший мінт використовуватиме індекс 0, другий — індекс 1 і т.д.

Після того, як у вас буде індекс листа, ви зможете похідно отримати відповідний asset ID для cNFT. Використовуючи Bubblegum, asset ID є PDA, який похідно отримується за допомогою ID програми Bubblegum і наступних seeds:

1. Статичний рядок `asset`, представлений у кодуванні UTF-8.
2. Адреса дерева Меркла.
3. Індекс листка.

Індексатор фактично спостерігає за журналами транзакцій з програми Noop під час їх виконання та зберігає метадані cNFT, які були зашифровані та збережені в дереві Меркла. Це дозволяє індексатору надавати ці дані за запитом. Цей asset ID є тим, що індексатор використовує для ідентифікації конкретного активу.

Для спрощення можна використовувати допоміжну функцію `getLeafAssetId` з SDK Bubblegum. Отримавши asset ID, отримати cNFT досить просто. Потрібно лише використати метод `getAsset`, наданий RPC-провайдером:

```tsx
const assetId = await getLeafAssetId(treeAddress, new BN(leafIndex))
const response = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAsset",
		params: {
			id: assetId,
		},
	}),
})

const { result } = await response.json()
console.log(JSON.stringify(result, null, 2))
```

Це поверне об'єкт JSON, який є поєднанням як ончейн, так і офчейн метаданих традиційного NFT. Наприклад, ви можете знайти атрибути cNFT в `content.metadata.attributes` або зображення в `content.files.uri`.

### Запит cNFT

Read API також надає можливості для отримання кількох активів, запитів за власником, творцем та іншими параметрами. Наприклад, Helius підтримує наступні методи:

- `getAsset`
- `getSignaturesForAsset`
- `searchAssets`
- `getAssetProof`
- `getAssetsByOwner`
- `getAssetsByAuthority`
- `getAssetsByCreator`
- `getAssetsByGroup`

Ми не будемо детально розглядати більшість з цих методів, але обов'язково ознайомтесь з [документацією Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), щоб дізнатися, як правильно їх використовувати.

### Трансфер cNFTs

Так само, як і в випадку зі стандартним переказом токенів SPL, безпека має вирішальне значення. Втім перевірити авторизацію при переказі токенів SPL дуже просто. Це вбудовано в програму SPL Token та стандартно підписується. Однак перевірка власності стисненого токена є складнішою. Фактична перевірка відбудеться на стороні програми, але вашому клієнтському коду потрібно надати додаткову інформацію, щоб це стало можливим.

Хоча у Bubblegum є допоміжна функція `createTransferInstruction`, для цього потрібно більше налаштувань, ніж зазвичай. Зокрема, програма Bubblegum повинна перевірити, що вся інформація про cNFT є такою, як вказує клієнт, перш ніж можна буде здійснити передачу. Уся інформація про cNFT була хешована та збережена як один лист на дереві Меркла, а саме дерево Меркла — це просто хеш усіх листів та гілок дерева. Тому ви не можете просто вказати програмі, на який акаунт звертатися, і дозволити їй порівняти поле `authority` або `owner` цього акаунту з підписантом транзакції.

Замість цього вам потрібно надати всю інформацію про cNFT і будь-яку інформацію про доказ дерева Меркла, яка не збережена в його кроні. Таким чином, програма може самостійно довести, що надані дані про cNFT, а отже, і власник cNFT, є правильними. Тільки після цього програма зможе безпечно визначити, чи підписант транзакції має право здійснити передачу cNFT.

В загальному, це процес з п'яти кроків:

1. Отримання даних активу cNFT з індексатора
2. Отримання доказів cNFT з індексатора
3. Отримання акаунта дерева Меркла з блокчейну Solana
4. Підготовка доказу активу у вигляді списку об'єктів `AccountMeta`
5. Формування та відправка інструкції на передачу через Bubblegum

Перші два кроки дуже схожі. Використовуючи свого RPC-провайдера, застосуйте методи `getAsset` та `getAssetProof` для отримання даних активу та доказів відповідно.

```tsx
const assetDataResponse = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAsset",
			params: {
				id: assetId,
			},
		}),
	})
const assetData = (await assetDataResponse.json()).result

const assetProofResponse = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAssetProof",
			params: {
				id: assetId,
			},
		}),
	})
const assetProof = (await assetProofResponse.json()).result
```

Третій крок — отримати акаунт дерева Меркла. Найпростіший спосіб зробити це — використати тип `ConcurrentMerkleTreeAccount` з бібліотеки `@solana/spl-account-compression`:

```tsx
const treePublicKey = new PublicKey(assetData.compression.tree)

const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
	connection,
	treePublicKey
)
```

Крок четвертий є найскладнішим з концептуальної точки зору. Використовуючи три зібрані частини інформації, вам потрібно зібрати шлях доказу для відповідного листка cNFT. Шлях доказу представлений у вигляді акаунтів, переданих до інструкції програми. Програма використовує кожну з адрес акаунтів, як доказові ноди, щоб підтвердити, що дані листка відповідають заявленим.

Повний доказ надається індексатором, як показано вище у `assetProof`. Однак ви можете виключити таку саму кількість акаунтів з кінця доказу, як глибина крони.

```tsx
const canopyDepth = treeAccount.getCanopyDepth() || 0

const proofPath: AccountMeta[] = assetProof.proof
	.map((node: string) => ({
	pubkey: new PublicKey(node),
	isSigner: false,
	isWritable: false
}))
.slice(0, assetProof.proof.length - canopyDepth)
```

Зрештою, ви можете зібрати інструкцію для передачі. Допоміжна функція `createTransferInstruction` вимагає наступних аргументів:

- `accounts` — список акаунтів для інструкції, який включає наступне:  
  - `merkleTree` — акаунт дерева Меркла  
  - `treeAuthority` — уповноважений акаунт дерева Меркла  
  - `leafOwner` — власник листка (cNFT), про який йде мова  
  - `leafDelegate` — делегат листка (cNFT); якщо делегата не було додано, то це значення має збігатися з `leafOwner`  
  - `newLeafOwner` — адреса нового власника після передачі  
  - `logWrapper` — програма, яку слід використовувати для надання даних індексаторам через логи; це має бути адреса програми SPL Noop, якщо ви не використовуєте стороннє рішення  
  - `compressionProgram` — програма для стиснення; це має бути адреса програми SPL State Compression, якщо ви не використовуєте стороннє рішення  
  - `anchorRemainingAccounts` — тут додається шлях доведення (proof path)  
- `args` — додаткові аргументи, необхідні для інструкції:  
  - `root` — коренева нода дерева Меркла з  доказу активу; надається індексатором у вигляді рядка та має бути спочатку конвертований у байти
  - `dataHash` — хеш даних активу, отриманих від індексатора; надається індексатором як рядок і має бути спочатку конвертований у байти  
  - `creatorHash` — хеш творця cNFT, отриманий від індексатора; надається індексатором як рядок і має бути спочатку конвертований у байти  
  - `nonce` — використовується для забезпечення унікальності хешів листків; це значення має бути таким же, як `index`  
  - `index` — індекс, у якому розташований листок cNFT у дереві Меркла
    
Приклад цього показано нижче. Зверніть увагу, що перші три рядки коду отримують додаткову інформацію, вкладену в об'єкти, показані раніше, щоб вона була готова до використання під час складання самої інструкції.

```tsx
const treeAuthority = treeAccount.getAuthority()
const leafOwner = new PublicKey(assetData.ownership.owner)
const leafDelegate = assetData.ownership.delegate
	? new PublicKey(assetData.ownership.delegate)
	: leafOwner

const transferIx = createTransferInstruction(
	{
		merkleTree: treePublicKey,
		treeAuthority,
		leafOwner,
		leafDelegate,
		newLeafOwner: receiver,
		logWrapper: SPL_NOOP_PROGRAM_ID,
		compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
		anchorRemainingAccounts: proofPath,
	},
	{
		root: [...new PublicKey(assetProof.root.trim()).toBytes()],
		dataHash: [...new PublicKey(assetData.compression.data_hash.trim()).toBytes()],
		creatorHash: [
			...new PublicKey(assetData.compression.creator_hash.trim()).toBytes(),
		],
		nonce: assetData.compression.leaf_id,
		index: assetData.compression.leaf_id,
	}
)
```

## Висновок

Ми розглянули основні навички, необхідні для взаємодії з cNFT, але не охопили всі аспекти повністю. Ви також можете використовувати Bubblegum для виконання таких дій, як спалювання, перевірка, делегування тощо. Ми не будемо розглядати ці дії детально, але їхні інструкції схожі на процеси створення та передачі. Якщо вам потрібен цей додатковий функціонал, ознайомтеся з [вихідним кодом клієнта Bubblegum](https://github.com/metaplex-foundation/mpl-bubblegum/tree/main/clients/js-solita) і скористайтеся допоміжними функціями, які він надає.

Майте на увазі, що технологія стиснення доволі нова. Доступні інструменти швидко розвиватимуться, але принципи, які ви вивчили в цьому уроці, ймовірно, залишаться незмінними. Ці принципи також можуть бути розширені на стиснення довільного стану, тому переконайтеся, що ви засвоїли їх тут, щоб бути готовими до нових цікавих уроків у майбутньому!

# Лабораторна робота

Давайте розпочнемо та попрактикуємося у створенні та роботі з cNFT. Разом ми напишемо максимально простий скрипт, який дозволить створити колекцію cNFT за допомогою дерева Меркла.

### 1. Візьміть стартовий код

Перш за все, клонуйте стартовий код з гілки `starter` нашого [репозиторію cNFT lab](https://github.com/Unboxed-Software/solana-cnft-demo).

`git clone https://github.com/Unboxed-Software/solana-cnft-demo.git`

`cd solana-cnft-demo`

`npm install`

Ознайомтеся зі стартовим кодом. Найважливіші — це допоміжні функції, розташовані в файлі `utils.ts`, а також URI, надані в файлі `uri.ts`.

Файл `uri.ts` містить 10 тис. URI, які ви можете використовувати для офчейн частини метаданих вашого NFT. Звісно, ви можете створювати свої власні метадані. Однак цей урок не спрямований на підготовку метаданих, тому ми надали вам готові.

Файл `utils.ts` містить кілька допоміжних функцій, щоб зменшити необхідність писати зайвий шаблонний код. Ось вони:

- `getOrCreateKeypair` — ця функція створить нову пару ключів для вас і збереже її у файлі `.env`, або, якщо вже є приватний ключ у файлі `.env`, ініціалізує пару ключів з цього значення.  
- `airdropSolIfNeeded` — ця функція надасть певну кількість SOL на зазначену адресу в Devnet, якщо баланс цієї адреси буде нижчим за 1 SOL.  
- `createNftMetadata` — ця функція створить метадані для NFT, використовуючи публічний ключ творця та індекс. Метадані є фіктивними і використовують URI, що відповідає зазначеному індексу зі списку `uri.ts`.
- `getOrCreateCollectionNFT` — ця функція перевірить, чи існує колекція NFT за адресою, зазначеною в `.env`. Якщо ні, функція створить нову колекцію NFT і додасть її адресу в `.env`.

Зрештою, в `index.ts` є деякий шаблонний код, який створює нове з'єднання з Devnet, викликає `getOrCreateKeypair` для ініціалізації "гаманця" і викликає `airdropSolIfNeeded`, щоб профінансувати гаманець, якщо його баланс недостатній.

Весь наш код ми будемо писати в `index.ts`.

### 2. Створення акаунту дерева Меркла

Ми почнемо зі створення акаунту дерева Меркла. Давайте інкапсулюємо це в функцію, яка зрештою створить *і* ініціалізує акаунт. Ми розмістимо її під нашою функцією `main` в `index.ts`. Назвемо її `createAndInitializeTree`. Для того, щоб ця функція працювала, їй будуть потрібні наступні параметри:

- `connection` - підключення `Connection`, яке буде використовуватися для взаємодії з мережею.
- `payer` - `Keypair`, який буде оплачувати транзакції.
- `maxDepthSizePair` - `ValidDepthSizePair`. Цей тип походить з `@solana/spl-account-compression`. Це простий об'єкт з властивостями `maxDepth` та `maxBufferSize`, який забезпечує правильну комбінацію цих двох значень.
- `canopyDepth` - число, що вказує глибину крони

    В середині функції ми згенеруємо нову адресу для дерева, а потім створимо інструкцію для виділення нового акаунту для дерева Меркла, викликавши `createAllocTreeIx` з `@solana/spl-account-compression`.


```tsx
async function createAndInitializeTree(
  connection: Connection,
  payer: Keypair,
  maxDepthSizePair: ValidDepthSizePair,
  canopyDepth: number
) {
	const treeKeypair = Keypair.generate()

	const allocTreeIx = await createAllocTreeIx(
    connection,
    treeKeypair.publicKey,
    payer.publicKey,
    maxDepthSizePair,
    canopyDepth
  )
}
```

### 3. Використання Bubblegum для ініціалізації дерева Меркла та створення акаунту конфігурації дерева

Маючи готову інструкцію для створення дерева, ми можемо створити інструкцію для виклику `create_tree` у програмі Bubblegum. Це ініціалізує акаунт дерева Меркла *і* створить новий акаунт конфігурації дерева у програмі Bubblegum.

Ця інструкція потребує від нас наступних даних:

- `accounts` - об'єкт необхідних акаунтів; це включає:
    - `treeAuthority` - це має бути PDA, отриманий за адресою дерева Меркла та програмою Bubblegum
    - `merkleTree` - адреса дерева Меркла
    - `payer` - платник комісії
    - `treeCreator` - адреса творця дерева; зробимо її такою ж, як і `payer`
    - `logWrapper` - зробіть це `SPL_NOOP_PROGRAM_ID`
    - `compressionProgram` - зробіть це `SPL_ACCOUNT_COMPRESSION_PROGRAM_ID`
- `args` - список аргументів інструкції; це включає:
    - `maxBufferSize` - розмір буфера з параметра `maxDepthSizePair` нашої функції
    - `maxDepth` - максимальна глибина з параметра `maxDepthSizePair` нашої функції
    - `public` - чи має дерево бути публічним; встановимо значення `false`

Нарешті, ми можемо додати обидві інструкції до транзакції і відправити транзакцію. Майте на увазі, що транзакція має бути підписана як `payer`, так і `treeKeypair`.

```tsx
async function createAndInitializeTree(
  connection: Connection,
  payer: Keypair,
  maxDepthSizePair: ValidDepthSizePair,
  canopyDepth: number
) {
	const treeKeypair = Keypair.generate()

	const allocTreeIx = await createAllocTreeIx(
    connection,
    treeKeypair.publicKey,
    payer.publicKey,
    maxDepthSizePair,
    canopyDepth
  )

	const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(
    [treeKeypair.publicKey.toBuffer()],
    BUBBLEGUM_PROGRAM_ID
  )

	const createTreeIx = createCreateTreeInstruction(
    {
      treeAuthority,
      merkleTree: treeKeypair.publicKey,
      payer: payer.publicKey,
      treeCreator: payer.publicKey,
      logWrapper: SPL_NOOP_PROGRAM_ID,
      compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    },
    {
      maxBufferSize: maxDepthSizePair.maxBufferSize,
      maxDepth: maxDepthSizePair.maxDepth,
      public: false,
    }
  )

	const tx = new Transaction().add(allocTreeIx, createTreeIx)
  tx.feePayer = payer.publicKey
  
  try {
    const txSignature = await sendAndConfirmTransaction(
      connection,
      tx,
      [treeKeypair, payer],
      {
        commitment: "confirmed",
        skipPreflight: true,
      }
    )

    console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)

    console.log("Tree Address:", treeKeypair.publicKey.toBase58())

    return treeKeypair.publicKey
  } catch (err: any) {
    console.error("\nFailed to create Merkle tree:", err)
    throw err
  }
}
```

Якщо ви хочете протестувати те, що ви вже зробили, не соромтесь викликати функцію `createAndInitializeTree` з функції `main` і передати малі значення для максимальної глибини та максимального розміру буфера.

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )
}
```

Майте на увазі, що Devnet SOL має обмеження, тому якщо ви тестуватимете занадто часто, ви можете вичерпати баланс Devnet SOL до того, як дійдемо до етапу мінта. Для тестування виконайте наступну команду в терміналі:

`npm run start`

### 4. Мінт cNFT у вашому дереві

Повірте, це все, що потрібно для налаштування вашого дерева для стиснутих NFT! Тепер приділимо увагу мінту.

Спочатку додамо функцію під назвою `mintCompressedNftToCollection`. Для цієї функції будуть потрібні наступні параметри:

- `connection` - з'єднання `Connection`, яке використовується для взаємодії з мережею.
- `payer` - `Keypair`, який буде платити за транзакції.
- `treeAddress` - адреса дерева Меркла.
- `collectionDetails` - деталі колекції типу `CollectionDetails` з файлу `utils.ts`.
- `amount` - кількість cNFT, яку потрібно мінтити.
  
Тіло цієї функції виконуватиме наступні кроки:

1. Отримає уповноважений акаунт дерева (tree authority), як і раніше. Це буде PDA, отримана з адреси дерева Меркла та програми Bubblegum.
2. Отримає `bubblegumSigner`. Це PDA, яка генерується з рядка `"collection_cpi"` та програми Bubblegum і є необхідною для мінта в колекцію.
3. Створить метадані для cNFT, викликавши функцію `createNftMetadata` з файлу `utils.ts`.
4. Створить інструкцію для мінта, викликавши функцію `createMintToCollectionV1Instruction` з SDK Bubblegum.
5. Побудує та надішле транзакцію з інструкцією мінта.
6. Повторить кроки 3-6, поки не змінтить потрібну кількість cNFT, визначену параметром `amount`.
   
`createMintToCollectionV1Instruction` приймає два аргументи: `accounts` та `args`. Останній — це просто метадані NFT. Як і з усіма складними інструкціями, основною проблемою є визначення правильних рахунків, які потрібно надати. Давайте швидко пройдемося по них:

- `payer` - рахунок, який буде оплачувати збори за транзакції, оренду тощо
- `merkleTree` - рахунок дерева Меркла
- `treeAuthority` - уповноважений акаунт дерева; має бути тою ж PDA, яку ви отримали раніше
- `treeDelegate` - делегат дерева; зазвичай зазвичай збігається з творцем дерева
- `leafOwner` - призначений власник стиснутого NFT, який буде мінтити
- `leafDelegate` - призначений делегат стиснутого NFT, що створюється; зазвичай збігається з власником
- `collectionAuthority` - уповноважений акаунт колекції NFT
`collectionAuthorityRecordPda` — це необов’язковий акаунт, який може містити дані про права уповноваженого акаунту колекції; зазвичай його немає, і в такому випадку слід вказати адресу програми Bubblegum
- `collectionMint` - рахунок мінта для колекції NFT
- `collectionMetadata` - рахунок метаданих для колекції NFT
- `editionAccount` – основний акаунт видання (master edition) колекційного NFT
- - `compressionProgram` - програма стиснення, яку потрібно використовувати; це має бути адреса програми SPL State Compression, якщо у вас немає іншого кастомного рішення
- `logWrapper` - програма, яка буде використовуватися для виведення даних для індексаторів через логи; це має бути адреса програми SPL Noop, якщо у вас немає іншого кастомного рішення
- `bubblegumSigner` - PDA, який використовує програма Bubblegum для перевірки колекції
- `tokenMetadataProgram` - програма метаданих токенів, яка використовувалась для колекції NFT; зазвичай це програма Metaplex Token Metadata
  
Коли ви складете все це разом, це буде виглядати так:

```tsx
async function mintCompressedNftToCollection(
  connection: Connection,
  payer: Keypair,
  treeAddress: PublicKey,
  collectionDetails: CollectionDetails,
  amount: number
) {
  // Derive the tree authority PDA ('TreeConfig' account for the tree account)
  const [treeAuthority] = PublicKey.findProgramAddressSync(
    [treeAddress.toBuffer()],
    BUBBLEGUM_PROGRAM_ID
  )

  // Derive the bubblegum signer, used by the Bubblegum program to handle "collection verification"
  // Only used for `createMintToCollectionV1` instruction
  const [bubblegumSigner] = PublicKey.findProgramAddressSync(
    [Buffer.from("collection_cpi", "utf8")],
    BUBBLEGUM_PROGRAM_ID
  )

  for (let i = 0; i < amount; i++) {
    // Compressed NFT Metadata
    const compressedNFTMetadata = createNftMetadata(payer.publicKey, i)

    // Create the instruction to "mint" the compressed NFT to the tree
    const mintIx = createMintToCollectionV1Instruction(
      {
        payer: payer.publicKey, // The account that will pay for the transaction
        merkleTree: treeAddress, // The address of the tree account
        treeAuthority, // The authority of the tree account, should be a PDA derived from the tree account address
        treeDelegate: payer.publicKey, // The delegate of the tree account, should be the same as the tree creator by default
        leafOwner: payer.publicKey, // The owner of the compressed NFT being minted to the tree
        leafDelegate: payer.publicKey, // The delegate of the compressed NFT being minted to the tree
        collectionAuthority: payer.publicKey, // The authority of the "collection" NFT
        collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID, // Must be the Bubblegum program id
        collectionMint: collectionDetails.mint, // The mint of the "collection" NFT
        collectionMetadata: collectionDetails.metadata, // The metadata of the "collection" NFT
        editionAccount: collectionDetails.masterEditionAccount, // The master edition of the "collection" NFT
        compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        logWrapper: SPL_NOOP_PROGRAM_ID,
        bubblegumSigner,
        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
      },
      {
        metadataArgs: Object.assign(compressedNFTMetadata, {
          collection: { key: collectionDetails.mint, verified: false },
        }),
      }
    )

    try {
      // Create new transaction and add the instruction
      const tx = new Transaction().add(mintIx)

      // Set the fee payer for the transaction
      tx.feePayer = payer.publicKey

      // Send the transaction
      const txSignature = await sendAndConfirmTransaction(
        connection,
        tx,
        [payer],
        { commitment: "confirmed", skipPreflight: true }
      )

      console.log(
        `https://explorer.solana.com/tx/${txSignature}?cluster=devnet`
      )
    } catch (err) {
      console.error("\nFailed to mint compressed NFT:", err)
      throw err
    }
  }
}
```

Це чудовий момент для тестування з невеликим деревом. Просто оновіть `main`, щоб викликати `getOrCreateCollectionNFT`, а потім `mintCompressedNftToCollection`.

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )

  const collectionNft = await getOrCreateCollectionNFT(connection, wallet)

  await mintCompressedNftToCollection(
    connection,
    wallet,
    treeAddress,
    collectionNft,
    2 ** maxDepthSizePair.maxDepth
  )
}
```

Щоб запустити, у вашому терміналі введіть: `npm run start`

### 5. Читання існуючих даних cNFT 

Тепер, коли ми написали код для створення cNFT, давайте подивимося, чи можемо ми фактично отримати їх дані. Це складно, оскільки ончейн дані — це лише акаунт дерева Меркла, інформація з якого може бути використана для перевірки правильності існуючих даних, але не дає безпосереднього доступу до самих даних.

Давайте почнемо з оголошення функції `logNftDetails`, яка прийматиме параметри `treeAddress` та `nftsMinted`.

На цьому етапі у нас немає безпосереднього ідентифікатора для нашого cNFT. Щоб отримати цей ідентифікатор, нам потрібно знати індекс листка, який був використаний під час мінта cNFT. Потім ми можемо використати цей індекс для отримання ID активу за допомогою Read API, а після цього використовувати Read API для отримання даних cNFT.

У нашому випадку ми створили непублічне дерево та випустили 8 cNFT, тому ми знаємо, що індекси листків, які використовувалися, були 0-7. Використовуючи це, ми можемо застосувати функцію `getLeafAssetId` з бібліотеки `@metaplex-foundation/mpl-bubblegum` для отримання ID активу.

Нарешті, ми можемо використати RPC, який підтримує [Read API](https://docs.solana.com/developing/guides/compressed-nfts#reading-compressed-nfts-metadata) для отримання активу. Ми використовуватимемо [Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), але ви можете вибрати будь-якого іншого провайдера RPC. Щоб використовувати Helius, вам потрібно отримати безкоштовний API ключ на [їхньому сайті](https://dev.helius.xyz/). Потім додайте `RPC_URL` до вашого файлу `.env`, наприклад:

```bash
# Add this
RPC_URL=https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY
```

Тоді просто виконайте POST-запит до наданого вами RPC URL і помістіть інформацію `getAsset` у тіло запиту:

```tsx
async function logNftDetails(treeAddress: PublicKey, nftsMinted: number) {
  for (let i = 0; i < nftsMinted; i++) {
    const assetId = await getLeafAssetId(treeAddress, new BN(i))
    console.log("Asset ID:", assetId.toBase58())
    const response = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const { result } = await response.json()
    console.log(JSON.stringify(result, null, 2))
  }
}
```

Helius фактично спостерігає за журналами транзакцій у режимі реального часу та зберігає метадані NFT, які були захешовані та збережені в дереві Меркла. Це дозволяє їм надавати ці дані за запитом.

Якщо додати виклик цієї функції наприкінці `main` і повторно запустити скрипт, дані, які ми отримаємо в консолі, будуть дуже детальними. Вони включають всю інформацію, яку ви очікуєте знайти як в ончейн, так і в офчейн частині традиційного NFT. Ви зможете знайти атрибути cNFT, файли, інформацію про власність і творців та багато іншого.

```json
{
  "interface": "V1_NFT",
  "id": "48Bw561h1fGFK4JGPXnmksHp2fpniEL7hefEc6uLZPWN",
  "content": {
    "$schema": "https://schema.metaplex.com/nft1.0.json",
    "json_uri": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.json",
    "files": [
      {
        "uri": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png",
        "cdn_uri": "https://cdn.helius-rpc.com/cdn-cgi/image//https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png",
        "mime": "image/png"
      }
    ],
    "metadata": {
      "attributes": [
        {
          "value": "183",
          "trait_type": "R"
        },
        {
          "value": "89",
          "trait_type": "G"
        },
        {
          "value": "78",
          "trait_type": "B"
        }
      ],
      "description": "Random RGB Color",
      "name": "CNFT",
      "symbol": "CNFT"
    },
    "links": {
      "image": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png"
    }
  },
  "authorities": [
    {
      "address": "DeogHav5T2UV1zf5XuH4DTwwE5fZZt7Z4evytUUtDtHd",
      "scopes": [
        "full"
      ]
    }
  ],
  "compression": {
    "eligible": false,
    "compressed": true,
    "data_hash": "3RsXHMBDpUPojPLZuMyKgZ1kbhW81YSY3PYmPZhbAx8K",
    "creator_hash": "Di6ufEixhht76sxutC9528H7PaWuPz9hqTaCiQxoFdr",
    "asset_hash": "2TwWjQPdGc5oVripPRCazGBpAyC5Ar1cia8YKUERDepE",
    "tree": "7Ge8nhDv2FcmnpyfvuWPnawxquS6gSidum38oq91Q7vE",
    "seq": 8,
    "leaf_id": 7
  },
  "grouping": [
    {
      "group_key": "collection",
      "group_value": "9p2RqBUAadMznAFiBEawMJnKR9EkFV98wKgwAz8nxLmj"
    }
  ],
  "royalty": {
    "royalty_model": "creators",
    "target": null,
    "percent": 0,
    "basis_points": 0,
    "primary_sale_happened": false,
    "locked": false
  },
  "creators": [
    {
      "address": "HASk3AoTPAvC1KnXSo6Qm73zpkEtEhbmjLpXLgvyKBkR",
      "share": 100,
      "verified": false
    }
  ],
  "ownership": {
    "frozen": false,
    "delegated": false,
    "delegate": null,
    "ownership_model": "single",
    "owner": "HASk3AoTPAvC1KnXSo6Qm73zpkEtEhbmjLpXLgvyKBkR"
  },
  "supply": {
    "print_max_supply": 0,
    "print_current_supply": 0,
    "edition_nonce": 0
  },
  "mutable": false,
  "burnt": false
}
```

Пам’ятайте, що Read API також включає способи отримання декількох активів, запити за власником, творцем тощо. Обов’язково перегляньте [документацію Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), щоб дізнатися, які можливості доступні.

### 6. Трансфер cNFT

Останнє, що ми додамо до нашого скрипту, — це трансфер cNFT. Як і у випадку зі стандартним трансфером токенів SPL, безпека має першочергове значення. Однак, на відміну від звичайного трансферу токенів SPL, для побудови безпечного трансферу з будь-яким типом стиснення стану програмі, що виконує трансфер, потрібні всі дані про актив.

Програма, у цьому випадку Bubblegum, повинна отримати всі дані, які були захешовані й збережені у відповідній ноді, *та* має отримати "proof path (щлях доказу)" для цієї ноди. Це робить передачу cNFT трохи складнішою, ніж передачу токенів SPL.

Запам’ятайте, загальні кроки такі:

1. Отримати дані активу cNFT з індексатора  
2. Отримати доказ cNFT з індексатора  
3. Отримати акаунт дерева Меркла з блокчейну Solana  
4. Підготувати доказ активу у вигляді списку об’єктів `AccountMeta`  
5. Створити та відправити інструкцію передачі Bubblegum
   
Почнемо з функції `transferNft`, яка приймає такі параметри:

- `connection` — об'єкт `Connection`  
- `assetId` — об'єкт `PublicKey`  
- `sender` — об'єкт `Keypair`, щоб ми могли підписати транзакцію  
- `receiver` — об'єкт `PublicKey`, що представляє нового власника
  
Всередині цієї функції повторно отримаємо дані активу, а також отримаємо доказ активу. Для надійності обгорнімо все у блок `try catch`.

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    const assetDataResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const assetData = (await assetDataResponse.json()).result

    const assetProofResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetProof",
        params: {
          id: assetId,
        },
      }),
    })
    const assetProof = (await assetProofResponse.json()).result
	} catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
	}
}
```

Далі отримаємо акаунт дерева Меркла з блокчейну, визначимо глибину крони (canopy depth) і зберемо шлях доказу. Для цього перетворимо доказ активу, отриманий від Helius, у список об’єктів `AccountMeta`, а потім видалимо всі доказові ноди в кінці, які вже кешовані на блокчейні в кроні.

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    ...

    const treePublicKey = new PublicKey(assetData.compression.tree)

    const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
      connection,
      treePublicKey
    )

    const canopyDepth = treeAccount.getCanopyDepth() || 0

    const proofPath: AccountMeta[] = assetProof.proof
      .map((node: string) => ({
        pubkey: new PublicKey(node),
        isSigner: false,
        isWritable: false,
      }))
      .slice(0, assetProof.proof.length - canopyDepth)
  } catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
  }
}
```

Зрештою, ми будуємо інструкцію за допомогою `createTransferInstruction`, додаємо її до транзакції, потім підписуємо і відправляємо транзакцію. Ось як виглядатиме вся функція `transferNft`, коли вона буде завершена:

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    const assetDataResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const assetData = (await assetDataResponse.json()).result

    const assetProofResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetProof",
        params: {
          id: assetId,
        },
      }),
    })
    const assetProof = (await assetProofResponse.json()).result

    const treePublicKey = new PublicKey(assetData.compression.tree)

    const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
      connection,
      treePublicKey
    )

    const canopyDepth = treeAccount.getCanopyDepth() || 0

    const proofPath: AccountMeta[] = assetProof.proof
      .map((node: string) => ({
        pubkey: new PublicKey(node),
        isSigner: false,
        isWritable: false,
      }))
      .slice(0, assetProof.proof.length - canopyDepth)

    const treeAuthority = treeAccount.getAuthority()
    const leafOwner = new PublicKey(assetData.ownership.owner)
    const leafDelegate = assetData.ownership.delegate
      ? new PublicKey(assetData.ownership.delegate)
      : leafOwner

    const transferIx = createTransferInstruction(
      {
        merkleTree: treePublicKey,
        treeAuthority,
        leafOwner,
        leafDelegate,
        newLeafOwner: receiver,
        logWrapper: SPL_NOOP_PROGRAM_ID,
        compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        anchorRemainingAccounts: proofPath,
      },
      {
        root: [...new PublicKey(assetProof.root.trim()).toBytes()],
        dataHash: [
          ...new PublicKey(assetData.compression.data_hash.trim()).toBytes(),
        ],
        creatorHash: [
          ...new PublicKey(assetData.compression.creator_hash.trim()).toBytes(),
        ],
        nonce: assetData.compression.leaf_id,
        index: assetData.compression.leaf_id,
      }
    )

    const tx = new Transaction().add(transferIx)
    tx.feePayer = sender.publicKey
    const txSignature = await sendAndConfirmTransaction(
      connection,
      tx,
      [sender],
      {
        commitment: "confirmed",
        skipPreflight: true,
      }
    )
    console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)
  } catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
  }
}
```

Давайте передамо наш перший стиснутий NFT з індексом 0 іншій особі. Спочатку нам потрібно створити інший гаманець з коштами, потім отримати assetID на індексі 0 за допомогою `getLeafAssetId`. Потім ми здійснимо передачу. І в кінці виведемо всю колекцію за допомогою нашої функції `logNftDetails`. Ви помітите, що NFT з індексом 0 тепер буде належати нашому новому гаманцю в полі `ownership`.

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )

  const collectionNft = await getOrCreateCollectionNFT(connection, wallet)

  await mintCompressedNftToCollection(
    connection,
    wallet,
    treeAddress,
    collectionNft,
    2 ** maxDepthSizePair.maxDepth
  )

  const recieverWallet = await getOrCreateKeypair("Wallet_2")
  const assetId = await getLeafAssetId(treeAddress, new BN(0))
  await airdropSolIfNeeded(recieverWallet.publicKey)

  console.log(`Transfering ${assetId.toString()} from ${wallet.publicKey.toString()} to ${recieverWallet.publicKey.toString()}`)

  await transferNft(
    connection,
    assetId,
    wallet,
    recieverWallet.publicKey
  )

  await logNftDetails(treeAddress, 8)
}
```

Запустіть свій скрипт. Все повинно виконатися без помилок, і все це за майже 0.01 SOL!

Вітаємо! Тепер ви знаєте, як створювати, зчитувати і передавати стиснуті NFT (cNFT). Якщо хочете, ви можете оновити максимальну глибину, максимальний розмір буфера та глибину крони до більших значень, і якщо у вас буде достатньо SOL на Devnet, цей скрипт дозволить вам створити до 10 000 cNFT за малу частину від вартості створення 10 000 традиційних NFT (Примітка: якщо ви плануєте створити велику кількість NFT, можливо, вам варто спробувати обробити ці інструкції групами для зменшення загальної кількості транзакцій).

Якщо вам потрібно більше часу для роботи з цією лабораторною, не соромтеся пройти її ще раз або подивитися код рішення на гілці `solution` репозиторію [lab repo](https://github.com/Unboxed-Software/solana-cnft-demo/tree/solution).

## Завдання

Тепер ваша черга спробувати ці концепції на практиці! Ми не будемо давати надто суворих вказівок, але ось кілька ідей:

1. Створіть свою власну колекцію cNFT
2. Розробіть інтерфейс, який дозволить вам створювати cNFT і відображати його
3. Спробуйте відтворити деякі функції зі скрипту лабораторної в смарт-контракті, тобто напишіть програму, яка може створювати cNFT


## Завершили лабораторну роботу?

Завантажте свій код на GitHub і [поділіться своїми враженнями від цього уроку](https://form.typeform.com/to/IPH0UGz7#answers-lesson=db156789-2400-4972-904f-40375582384a)!
