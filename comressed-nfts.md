---
назва: Стиснуті NFT
мета:
- Створити колекцію стиснутих NFT за допомогою програми Bubblegum від Metaplex
- Мінт стиснених NFT за допомогою Bubblegum TS SDK
- Передача стислих NFT за допомогою Bubblegum TS SDK
- Читання стиснених NFT-даних за допомогою Read API
---

# Підсумок

- **Стислі NFT (cNFT)** використовують **State Compression (Стиснення стану)** для хешування даних NFT і зберігають хеш-ланцюжок в обліковому записі за допомогою **одночасної структури Merkle Tree**.
- Хеш даних cNFT не може бути використаний для виведення даних cNFT, але він може бути використаний для **перевірки**, чи правильні дані cNFT, які ви бачите
- Підтримка RPC-провайдерів **індексує** дані cNFT поза ланцюжком при створенні cNFT, щоб ви могли використовувати **Read API** для доступу до даних
- Програма **Metaplex Bubblegum** - це абстракція над програмою **State Compression**, яка дозволяє вам простіше створювати, мінтити та керувати колекціями cNFT

# Урок

Стиснуті NFT (cNFT) - це саме те, про що свідчить їхня назва: NFT, структура яких займає менше місця для зберігання даних, ніж традиційні NFT. Стиснуті NFT використовують концепцію під назвою **State Compression** для зберігання даних у спосіб, який значно знижує витрати.

Транзакційні витрати Solana настільки низькі, що більшість користувачів ніколи не замислюються про те, наскільки дорогим може бути карбування NFT в масштабах. Вартість створення і карбування 1 мільйона традиційних NFT становить приблизно 24 000 SOL. Для порівняння, cNFT можна структурувати так, щоб ті ж самі налаштування і мінт коштували 10 SOL або менше. Це означає, що кожен, хто використовує NFT у великих масштабах, може скоротити витрати більш ніж у 1000 разів, використовуючи cNFT замість традиційних NFT.

Однак, з cNFT може бути складно працювати. З часом інструментарій, необхідний для роботи з ними, буде настільки абстрагований від базової технології, що різниця в досвіді розробників між традиційними NFT і cNFT буде незначною. Але поки що вам все одно потрібно буде розібратися в базових поняттях цієї теми, тож давайте почнемо!

## Теоретичний огляд cNFT

Більшість витрат, пов'язаних з традиційними NFT, зводяться до простору для зберігання облікових записів. Стиснуті NFT використовують концепцію під назвою «State Compression» для зберігання даних у дешевшому «ledger state», використовуючи більш дорогий простір облікового запису лише для зберігання «fingerprint», або «hash», даних. Цей хеш дозволяє криптографічно перевірити, що дані не були підроблені.

Для зберігання хешів та перевірки ми використовуємо спеціальну структуру бінарного дерева, відому як **concurrent Merkle tree (одночасне дерево Меркла)**. Ця деревоподібна структура дозволяє нам хешувати дані разом у детермінований спосіб, щоб обчислити єдиний остаточний хеш, який зберігається в ланцюжку. Цей кінцевий хеш значно менший за розміром, ніж всі вихідні дані разом узяті, звідси і «стиснення». Етапи цього процесу наступні:

1. Візьміть будь-який фрагмент даних
2. Створіть хеш цих даних
3. Зберігаємо цей хеш у вигляді «листка» внизу дерева
4. Потім кожна пара листків хешується разом, створюючи «гілку»
5. Потім кожна гілка хешується разом
6. Безперервно піднімайтеся по дереву і хешуйте сусідні гілки разом
7. На вершині дерева створюється остаточний «кореневий хеш»
8. Зберігайте кореневий хеш в ланцюжку як перевірений доказ даних на кожному листку
9. Будь-хто, хто хоче перевірити, чи відповідають його дані «джерелу істини», може пройти той самий процес і порівняти кінцевий хеш без необхідності зберігати всі дані в ланцюжку
    
Однією з проблем, не розглянутих вище, є те, як зробити дані доступними, якщо їх не можна отримати з облікового запису. Оскільки процес хешування відбувається в ланцюжку, всі дані існують у стані реєстру і теоретично можуть бути отримані з оригінальної транзакції шляхом відтворення всього стану ланцюжка від початку. Однак, набагато простіше (хоча і складніше) мати **індексатор** і індексувати ці дані по мірі виконання транзакцій. Це гарантує наявність позаланцюгового «кешу» даних, до якого будь-хто може отримати доступ і згодом звірити його з кореневим хешем ланцюжка.

Цей процес є *дуже складним*. Нижче ми розглянемо деякі ключові поняття, але не хвилюйтеся, якщо ви не зрозумієте їх одразу. Ми поговоримо про теорію в уроці про стиснення стану, а в цьому уроці зосередимося в першу чергу на застосуванні до NFT. Наприкінці цього уроку ви зможете працювати з cNFT, навіть якщо не будете повністю розуміти кожну частину головоломки стиснення станів.
  
### Concurrent Merkle trees

Дерево Меркла - це бінарна деревоподібна структура, представлена одним хешем. Кожен вузол листка в структурі є хешем своїх внутрішніх даних, а кожна гілка - хешем хешів своїх дочірніх листків. У свою чергу, гілки також хешуються разом, поки врешті-решт не залишиться один остаточний хеш кореня.

Будь-яка модифікація даних листків змінює кореневий хеш. Це спричиняє проблему, коли декілька транзакцій в одному слоті намагаються змінити дані листків. Оскільки ці транзакції повинні виконуватися послідовно, всі, крім першої, зазнають невдачі, оскільки кореневий хеш і доказ, переданий першою транзакцією, буде визнано недійсним.

**Concurrent Merkle trees** - це дерево Меркла, яке зберігає логи останніх змін разом з їхнім кореневим хешем і доказом його отримання. Коли декілька транзакцій в одному слоті намагаються змінити дані листків, журнал змін може бути використаний як джерело істини, щоб дозволити одночасне внесення змін до дерева.

При роботі з паралельним деревом Меркла є три змінні, які визначають розмір дерева, вартість створення дерева і кількість одночасних змін, які можуть бути зроблені в дереві:

1. Максимальна глибина
2. Максимальний розмір буфера
3. Глибина навісу
   
**Максимальна глибина** - це максимальна кількість стрибків, які можна зробити, щоб дістатися від будь-якого листка до кореня дерева. Оскільки дерева Меркла є бінарними деревами, кожен лист з'єднаний лише з одним іншим листом. Максимальну глибину можна логічно використати для обчислення кількості вузлів дерева за формулою `2 ^ maxDepth`.

**Максимальний розмір буфера** - це фактично максимальна кількість одночасних змін, які ви можете зробити у дереві в межах одного слоту, при цьому кореневий хеш все ще буде дійсним.

**Глибина накриття** - це кількість вершин доказу, які зберігаються в ланцюжку для будь-якого заданого шляху доказу. Для перевірки будь-якого листка потрібен повний шлях доведення для дерева. Повний шлях доказу складається з однієї доказової вершини для кожного «шару» дерева, тобто максимальна глибина 14 означає, що існує 14 доказових вершин. Кожен вузол доказу додає 32 байти до транзакції, тому великі дерева швидко перевищать максимальний розмір транзакції без кешування вузлів доказу в ланцюжку.

Кожне з цих трьох значень, максимальна глибина, максимальний розмір буфера і глибина навісу, має певний компроміс. Збільшення будь-якого з цих значень збільшує розмір облікового запису, який використовується для зберігання дерева, таким чином збільшуючи вартість створення дерева. 

Вибір максимальної глибини досить простий, оскільки він безпосередньо пов'язаний з кількістю листків і, отже, з кількістю даних, які ви можете зберігати. Якщо вам потрібно 1 мільйон cNFT для одного дерева, знайдіть максимальну глибину, при якій виконується наступний вираз: `2^maxDepth > 1million`. Відповідь: 20.

Вибір максимального розміру буфера - це фактично питання пропускної здатності: скільки одночасних записів вам потрібно.

### Програми стиснення стану SPL і Noop

Програма стиснення стану SPL існує для того, щоб зробити вищезгаданий процес повторюваним і комбінованим у всій екосистемі Solana. Вона надає інструкції для ініціалізації дерев Меркла, керування листям дерев (тобто додавання, оновлення, видалення даних) та перевірки даних про листя.

Програма стиснення стану (State Compression Program) також використовує окрему програму "no op" (без операцій), основною метою якої є спрощення індексації даних листів шляхом запису їх до стану реєстру.

### Використання стану реєстру для зберігання

Реєстр Solana — це список записів, які містять підписані транзакції. Теоретично, він може бути простежений аж до початкового блоку (genesis block). Це означає, що будь-які дані, які коли-небудь були включені до транзакції, залишаються в реєстрі.

Коли ви хочете зберігати стиснені дані, ви передаєте їх до програми стиснення стану (State Compression program), де вони хешуються та надсилаються як "подія" до програми Noop. Потім хеш зберігається у відповідному паралельному дереві Меркла (concurrent Merkle tree). Оскільки дані проходять через транзакцію та навіть зберігаються в логах програми Noop, вони назавжди залишаються у стані реєстру.

### Індексуйте дані для легкого пошуку

За звичайних умов ви зазвичай отримуєте доступ до даних в ланцюжку, вибравши відповідний обліковий запис. Однак при використанні стиснення все не так просто. 

Як згадувалося вище, дані тепер існують у стані реєстру, а не в обліковому записі. Найпростіше знайти повні дані в журналах інструкції Noop, але хоча ці дані в певному сенсі будуть існувати в стані реєстру назавжди, вони, ймовірно, будуть недоступні через валідатори через певний проміжок часу.

Для економії місця і підвищення продуктивності валідатори не зберігають кожну транзакцію в генезис блоці. Конкретний проміжок часу, протягом якого ви зможете отримати доступ до логів інструкцій Noop, пов'язаних з вашими даними, буде залежати від валідатора, але в кінцевому підсумку ви втратите доступ до них, якщо ви покладаєтесь безпосередньо на журнали інструкцій.

Технічно, ви можете відтворити стан транзакції назад до блоку генезис, але середньостатистична команда не буде цього робити, і це, безумовно, не буде продуктивно. Замість цього, вам слід використовувати індексатор, який буде спостерігати за подіями, що надсилаються до програми Noop, і зберігати відповідні дані поза ланцюжком. Таким чином, вам не потрібно турбуватися про те, що старі дані стануть недоступними.

## Створення колекції cNFT

Після теоретичного огляду перейдемо до основної частини цього уроку: створення колекції cNFT.

На щастя, ви можете скористатися інструментами, створеними Solana Foundation, спільнотою розробників Solana та Metaplex, щоб спростити цей процес. Зокрема, ми використовуватимемо SDK `@solana/spl-account-compression`, програму Metaplex Bubblegum і відповідний TS SDK програми Bubblegum — `@metaplex-foundation/mpl-bubblegum`.

<aside>
💡 **На момент написання** команда Metaplex переходить на новий SDK клієнта Bubblegum, який підтримує Umi — їх модульний фреймворк для створення та використання JS-клієнтів для програм Solana. У цьому уроці ми не використовуватимемо версію SDK із підтримкою Umi. Натомість ми зафіксуємо нашу залежність на версії 0.7 (`@metaplex-foundation/mpl-bubblegum@0.7`). Ця версія надає прості функції-помічники для створення інструкцій Bubblegum.
</aside>

### Підготуйте метадані

Перед початком вам потрібно підготувати метадані для ваших NFT так само, як ви б це робили при використанні Candy Machine. По суті, NFT — це просто токен із метаданими, які відповідають стандарту NFT. Іншими словами, вони мають виглядати приблизно так:

```json
{
  "name": "12_217_47",
  "symbol": "RGB",
  "description": "Random RGB Color",
  "seller_fee_basis_points": 0,
  "image": "https://raw.githubusercontent.com/ZYJLiu/rgb-png-generator/master/assets/12_217_47/12_217_47.png",
  "attributes": [
    {
      "trait_type": "R",
      "value": "12"
    },
    {
      "trait_type": "G",
      "value": "217"
    },
    {
      "trait_type": "B",
      "value": "47"
    }
  ]
}
```

Залежно від вашого випадку використання, ви можете генерувати це динамічно або підготувати JSON-файл для кожного cNFT заздалегідь. Вам також знадобляться всі інші ресурси, на які посилається JSON, наприклад, URL зображення `image`, як показано в наведеному вище прикладі.

### Створення NFT колекції

Якщо ви хочете, щоб ваші cNFT стали частиною колекції, вам потрібно створити NFT колекцію **до** того, як ви почнете мінтити cNFT. Це традиційний NFT, який діє як посилання, що зв'язує ваші cNFT в єдину колекцію. Ви можете створити цей NFT за допомогою бібліотеки `@metaplex-foundation/js`. Просто переконайтеся, що ви встановили `isCollection` у значення `true`.

```tsx
const collectionNft = await metaplex.nfts().create({
    uri: someUri,
    name: "Collection NFT",
    sellerFeeBasisPoints: 0,
    updateAuthority: somePublicKey,
    mintAuthority: somePublicKey,
    tokenStandard: 0,
    symbol: "Collection",
    isMutable: true,
    isCollection: true,
})
```

### Створення Merkle tree Account

Тепер ми починаємо відхилятися від процесу, який ви використовуєте при створенні традиційних NFT. Механізм ончейн-сховища, який ви використовуєте для стиснення станів, - це обліковий запис, що представляє паралельне дерево Меркла. Цей обліковий запис дерева Меркла належить програмі стиснення станів SPL. Перш ніж ви зможете робити щось, пов'язане з cNFT, вам потрібно створити порожній обліковий запис дерева Меркла відповідного розміру.

Змінними, що впливають на розмір облікового запису, є:

1. Максимальна глибина (Max depth) 
2. Максимальний розмір буфера (Max buffer size) 
3. Глибина "крони" (Canopy depth)

Перші дві змінні необхідно вибрати з існуючого набору допустимих пар. У таблиці нижче наведено допустимі пари, а також кількість cNFT, які можна створити з цими значеннями.

| Max Depth | Max Buffer Size | Max Number of cNFTs |
| --- | --- | --- |
| 3 | 8 | 8 |
| 5 | 8 | 32 |
| 14 | 64 | 16,384 |
| 14 | 256 | 16,384 |
| 14 | 1,024 | 16,384 |
| 14 | 2,048 | 16,384 |
| 15 | 64 | 32,768 |
| 16 | 64 | 65,536 |
| 17 | 64 | 131,072 |
| 18 | 64 | 262,144 |
| 19 | 64 | 524,288 |
| 20 | 64 | 1,048,576 |
| 20 | 256 | 1,048,576 |
| 20 | 1,024 | 1,048,576 |
| 20 | 2,048 | 1,048,576 |
| 24 | 64 | 16,777,216 |
| 24 | 256 | 16,777,216 |
| 24 | 512 | 16,777,216 |
| 24 | 1,024 | 16,777,216 |
| 24 | 2,048 | 16,777,216 |
| 26 | 512 | 67,108,864 |
| 26 | 1,024 | 67,108,864 |
| 26 | 2,048 | 67,108,864 |
| 30 | 512 | 1,073,741,824 |
| 30 | 1,024 | 1,073,741,824 |
| 30 | 2,048 | 1,073,741,824 |

Зверніть увагу, що кількість cNFTs, які можна зберігати у дереві, повністю залежить від **максимальної глибини**, тоді як **розмір буфера** визначає кількість одночасних змін (мінтів, трансферів тощо), які можуть відбутися в дереві в тому самому слоті. Іншими словами, виберіть максимальну глибину, яка відповідає кількості NFT, які ви хочете зберігати у дереві, а потім оберіть одну з доступних опцій для максимального розміру буфера, виходячи з очікуваного рівня трафіку.

Далі оберіть **глибину крони**. Збільшення глибини крони підвищує композиційність ваших cNFT. Щоразу, коли ваш код або код іншого розробника намагатиметься перевірити cNFT, доведеться передавати стільки доказових вузлів, скільки є «шарів» у вашому дереві. Наприклад, для дерева з максимальною глибиною 20 потрібно буде передавати 20 доказових вузлів. Це не лише ускладнює процес, але й створює ризик перевищення розміру транзакції, оскільки кожен доказовий вузол займає 32 байти.

Наприклад, якщо у вашому дереві дуже мала глибина крони, NFT-маркетплейс може підтримувати лише прості перекази NFT, але не зможе реалізувати функції на кшталт ончейн-системи ставок для ваших cNFT. Крона фактично кешує доказові вузли ончейн, тож вам не потрібно передавати їх усі в транзакції, що дозволяє проводити більш складні операції.

Збільшення будь-якого з цих трьох параметрів збільшує розмір акаунта, а отже, і вартість його створення. Зважуйте переваги відповідно до ваших потреб при виборі значень.

Коли ви визначитеся з цими параметрами, ви можете скористатися функцією-хелпером `createAllocTreeIx` з TS SDK пакету `@solana/spl-account-compression`, щоб створити інструкцію для створення порожнього акаунта.

```tsx
import { createAllocTreeIx } from "@solana/spl-account-compression"

const treeKeypair = Keypair.generate()

const allocTreeIx = await createAllocTreeIx(
  connection,
  treeKeypair.publicKey,
  payer.publicKey,
  { maxDepth: 20; maxBufferSize: 256 },
  canopyDepth
)
```

Зверніть увагу, що це лише функція-хелпер для розрахунку необхідного розміру акаунта та створення інструкції, яку потрібно надіслати до System Program для виділення акаунта. Ця функція поки що не взаємодіє з жодними програмами для компресії.

### ### Використання Bubblegum для ініціалізації вашого дерева

Після створення акаунта для порожнього дерева ви можете використати програму **Bubblegum** для його ініціалізації. Окрім акаунта дерева Merkle, Bubblegum створює акаунт конфігурації дерева, щоб додати функціонал і трекінг для cNFT.

Версія 0.7 TypeScript SDK `@metaplex-foundation/mpl-bubblegum` надає функцію-хелпер `createCreateTreeInstruction`, яка використовується для виклику інструкції `create_tree` у програмі Bubblegum. Під час виклику цієї функції необхідно отримати `treeAuthority` PDA (програмно визначений акаунт), який очікує програма. Цей PDA генерується з використанням адреси дерева як seed.

```tsx
import {
	createAllocTreeIx,
	SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
  SPL_NOOP_PROGRAM_ID,
} from "@solana/spl-account-compression"
import {
  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,
  createCreateTreeInstruction,
} from "@metaplex-foundation/mpl-bubblegum"

...

const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(
  [treeKeypair.publicKey.toBuffer()],
  BUBBLEGUM_PROGRAM_ID
)

const createTreeIx = createCreateTreeInstruction(
  {
    treeAuthority,
    merkleTree: treeKeypair.publicKey,
    payer: payer.publicKey,
    treeCreator: payer.publicKey,
    logWrapper: SPL_NOOP_PROGRAM_ID,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
  },
  {
    maxBufferSize: 256,
    maxDepth: 20,
    public: false,
  },
  BUBBLEGUM_PROGRAM_ID
)
```

Нижче наведено список необхідних вхідних даних для цієї функції-хелпера:

- `accounts` - Об'єкт, що представляє акаунти, потрібні для інструкції. Він включає:
    - `treeAuthority` - Bubblegum очікує, що це буде PDA (програмно визначений акаунт), створений з використанням адреси дерева Merkle як seed
    - `merkleTree` - Акаунт дерева Merkle
    - `payer` - Адреса, яка сплачує комісії за транзакцію, оренду тощо
    - `treeCreator` - Адреса, яка буде вказана як творець дерева
    - `logWrapper` - Програма, яка використовується для передачі даних індексаторам через логи; це має бути адреса програми SPL Noop, якщо у вас немає іншого кастомного рішення
    - `compressionProgram` - Програма компресії, яка використовується для ініціалізації дерева Merkle; це має бути адреса програми SPL State Compression, якщо у вас немає іншого кастомного рішення
- `args` - Об'єкт, що представляє додаткові аргументи, потрібні для інструкції. Він включає:
    - `maxBufferSize` - Максимальний розмір буфера дерева Merkle
    - `maxDepth` - Максимальна глибина дерева Merkle
    - `public` - Якщо встановлено значення `true`, будь-хто зможе створювати cNFT у цьому дереві; якщо встановлено значення `false`, тільки творець дерева або делегат дерева зможе створювати cNFT

Після подання це викличе інструкцію `create_tree` у програмі Bubblegum. Ця інструкція виконує три дії:

1. Створює PDA акаунт конфігурації дерева.  
2. Ініціалізує акаунт конфігурації дерева з відповідними початковими значеннями.  
3. Виконує CPI (виклик програмної інтерфейсу) до програми State Compression для ініціалізації порожнього акаунта дерева Merkle.  

Ви можете переглянути код програми [тут](https://github.com/metaplex-foundation/mpl-bubblegum/blob/main/programs/bubblegum/program/src/lib.rs#L887).

### Мінт cNFTs

Після ініціалізації акаунта дерева Merkle та відповідного акаунта конфігурації дерева Bubblegum, ви можете карбувати cNFT у дереві. Для цього у програмі Bubblegum можна використовувати інструкції `mint_v1` або `mint_to_collection_v1`, залежно від того, чи хочете ви, щоб викарбуваний cNFT був частиною колекції.

Версія 0.7 TS SDK `@metaplex-foundation/mpl-bubblegum` надає допоміжні функції `createMintV1Instruction` і `createMintToCollectionV1Instruction`, щоб спростити створення цих інструкцій.

Обидві функції потребують передачі метаданих NFT та списку акаунтів, необхідних для карбування cNFT. Нижче наведено приклад карбування до колекції:

```tsx
const mintWithCollectionIx = createMintToCollectionV1Instruction(
  {
    payer: payer.publicKey,
    merkleTree: treeAddress,
    treeAuthority,
    treeDelegate: payer.publicKey,
    leafOwner: destination,
    leafDelegate: destination,
    collectionAuthority: payer.publicKey,
    collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,
    collectionMint: collectionDetails.mint,
    collectionMetadata: collectionDetails.metadata,
    editionAccount: collectionDetails.masterEditionAccount,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    logWrapper: SPL_NOOP_PROGRAM_ID,
    bubblegumSigner,
    tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
  },
  {
    metadataArgs: Object.assign(nftMetadata, {
      collection: { key: collectionDetails.mint, verified: false },
    }),
  }
)
```

Зверніть увагу, що допоміжна функція має два аргументи: `accounts` і `args`. Параметр `args` — це просто метадані NFT, тоді як `accounts` — це об'єкт, який містить список акаунтів, необхідних для виконання інструкції. Слід визнати, що їх досить багато:

- `payer` — акаунт, що оплачуватиме комісії за транзакцію, оренду тощо.  
- `merkleTree` — акаунт дерева Меркла.  
- `treeAuthority` — авторитет дерева; має бути тим самим PDA, який ви отримали раніше.  
- `treeDelegate` — делегат дерева; зазвичай це той самий акаунт, що й творець дерева.  
- `leafOwner` — бажаний власник стисненого NFT, що карбується.  
- `leafDelegate` — бажаний делегат стисненого NFT, що карбується; зазвичай це той самий акаунт, що й власник leaf.  
- `collectionAuthority` — авторитет колекції NFT.  
- `collectionAuthorityRecordPda` — опційний запис авторитету колекції PDA; зазвичай його немає, у такому випадку слід вказати адресу програми Bubblegum.  
- `collectionMint` — мінт-акаунт для колекції NFT.  
- `collectionMetadata` — акаунт метаданих для колекції NFT.  
- `editionAccount` — акаунт головного видання колекції NFT.  
- `compressionProgram` — програма для стиснення; має бути адресою програми SPL State Compression, якщо у вас немає власного рішення.  
- `logWrapper` — програма для передачі даних у логах для індексаторів; має бути адресою програми SPL Noop, якщо у вас немає власного рішення.  
- `bubblegumSigner` — PDA, який використовує програма Bubblegum для перевірки колекції.  
- `tokenMetadataProgram` — програма метаданих токенів, яка використовувалася для колекції NFT; зазвичай це програма Metaplex Token Metadata.  

Мінт без колекції вимагає менше акаунтів, жоден з яких не є ексклюзивним для мінту без колекції. Ви можете подивитись приклад нижче.

```tsx
const mintWithoutCollectionIx = createMintV1Instruction(
  {
    payer: payer.publicKey,
    merkleTree: treeAddress,
    treeAuthority,
    treeDelegate: payer.publicKey,
    leafOwner: destination,
    leafDelegate: destination,
    compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    logWrapper: SPL_NOOP_PROGRAM_ID,
  },
  {
    message: nftMetadata,
  }
)
```

## Взаємодія з cNFTs

Важливо зазначити, що cNFT не є токенами SPL. Це означає, що вашому коду необхідно слідувати іншим конвенціям для обробки функціональності cNFT, такої як отримання, запит, передача тощо.

### Отримання даних cNFT 

Найпростіший спосіб отримати дані про існуючий cNFT — це використовувати [Read API стандарту цифрових активів](https://docs.solana.com/developing/guides/compressed-nfts#reading-compressed-nfts-metadata) (Read API). Зверніть увагу, що це окремо від стандартного JSON RPC. Для використання Read API вам потрібно використовувати підтримуваного RPC-постачальника. Metaplex підтримує (ймовірно, не вичерпний) [список RPC постачальників](https://developers.metaplex.com/bubblegum/rpcs), які підтримують Read API. У цьому уроці ми будемо використовувати [Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), оскільки вони надають безкоштовну підтримку для Devnet.

Щоб використовувати Read API для отримання конкретного cNFT, вам потрібно знати його asset ID. Однак після створення cNFT ви матимете максимум дві види інформації:

1. Підпис транзакції  
2. Індекс листа (leaf) (можливо)

Єдина справжня гарантія — це підпис транзакції. **Можливо** знайти індекс листа на його основі, але це вимагає складного парсингу. Коротко кажучи, потрібно отримати відповідні логи інструкцій з програми Noop і зпарсити їх, щоб знайти індекс листа. Ми детально розглянемо це в майбутньому уроці. На даний момент припустимо, що ви знаєте індекс листа.

Це розумне припущення для більшості мінтів, оскільки мінт буде контролюватися вашим кодом, і можна налаштувати його так, щоб ваш код міг відслідковувати, який індекс буде використовуватися кожного разу. Тобто, перший мінт використовуватиме індекс 0, другий — індекс 1 і т.д.

Після того, як у вас буде індекс листа, ви зможете похідно отримати відповідний asset ID для cNFT. Використовуючи Bubblegum, asset ID є PDA, який похідно отримується за допомогою ID програми Bubblegum і наступних seeds:

1. Статичний рядок `asset`, представлений у кодуванні UTF-8.
2. Адреса Меркле-дерева.
3. Індекс листа.
   
Індексатор фактично спостерігає за журналами транзакцій з програми Noop під час їх виконання та зберігає метадані cNFT, які були зашифровані та збережені в Меркле-дереві. Це дозволяє індексатору надавати ці дані за запитом. Цей asset ID є тим, що індексатор використовує для ідентифікації конкретного активу.

Для спрощення можна використовувати допоміжну функцію `getLeafAssetId` з SDK Bubblegum. Отримавши asset ID, отримати cNFT досить просто. Потрібно лише використати метод `getAsset`, наданий RPC-провайдером:

```tsx
const assetId = await getLeafAssetId(treeAddress, new BN(leafIndex))
const response = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAsset",
		params: {
			id: assetId,
		},
	}),
})

const { result } = await response.json()
console.log(JSON.stringify(result, null, 2))
```

Це поверне об'єкт JSON, який є поєднанням як ончейн, так і оффчейн метаданих традиційного NFT. Наприклад, ви можете знайти атрибути cNFT в `content.metadata.attributes` або зображення в `content.files.uri`.

### Запит cNFT

Read API також надає можливості для отримання кількох активів, запитів за власником, творцем та іншими параметрами. Наприклад, Helius підтримує наступні методи:

- `getAsset`
- `getSignaturesForAsset`
- `searchAssets`
- `getAssetProof`
- `getAssetsByOwner`
- `getAssetsByAuthority`
- `getAssetsByCreator`
- `getAssetsByGroup`

Ми не будемо детально розглядати більшість з цих методів, але обов'язково ознайомтесь з [документацією Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), щоб дізнатися, як правильно їх використовувати.

### Трансфер cNFTs

Так само, як і в випадку зі стандартним переказом токенів SPL, безпека має вирішальне значення. Втім перевірити авторизацію при переказі токенів SPL дуже просто. Це вбудовано в програму SPL Token та стандартно підписується. Однак перевірка власності стисненого токена є складнішою. Фактична перевірка відбудеться на стороні програми, але вашому клієнтському коду потрібно надати додаткову інформацію, щоб це стало можливим.

Хоча у Bubblegum є допоміжна функція `createTransferInstruction`, для цього потрібно більше налаштувань, ніж зазвичай. Зокрема, програма Bubblegum повинна перевірити, що вся інформація про cNFT є такою, як вказує клієнт, перш ніж можна буде здійснити передачу. Уся інформація про cNFT була хешована та збережена як один лист на Меркле-дереві, а саме дерево Меркле — це просто хеш усіх листів та гілок дерева. Тому ви не можете просто вказати програмі, на який обліковий запис звертатися, і дозволити їй порівняти поле `authority` або `owner` цього облікового запису з підписантом транзакції.

Замість цього вам потрібно надати всю інформацію про cNFT і будь-яку інформацію про доказ Меркле-дерева, яка не збережена в його "кроні" (canopy). Таким чином, програма може самостійно довести, що надані дані про cNFT, а отже, і власник cNFT, є правильними. Тільки після цього програма зможе безпечно визначити, чи підписант транзакції має право здійснити передачу cNFT.

В загальному, це процес з п'яти кроків:

1. Отримання даних активу cNFT з індексера.
2. Отримання доказів cNFT з індексера.
3. Отримання акаунта Меркле-дерева з блокчейну Solana.
4. Підготовка доказу активу у вигляді списку об'єктів `AccountMeta`.
5. Формування та відправка інструкції на передачу через Bubblegum.

Перші два кроки дуже схожі. Використовуючи свого RPC-провайдера, застосуйте методи `getAsset` та `getAssetProof` для отримання даних активу та доказів відповідно.

```tsx
const assetDataResponse = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAsset",
			params: {
				id: assetId,
			},
		}),
	})
const assetData = (await assetDataResponse.json()).result

const assetProofResponse = await fetch(process.env.RPC_URL, {
	method: "POST",
	headers: { "Content-Type": "application/json" },
	body: JSON.stringify({
		jsonrpc: "2.0",
		id: "my-id",
		method: "getAssetProof",
			params: {
				id: assetId,
			},
		}),
	})
const assetProof = (await assetProofResponse.json()).result
```

Третій крок — отримати обліковий запис Меркле-дерева. Найпростіший спосіб зробити це — використати тип `ConcurrentMerkleTreeAccount` з бібліотеки `@solana/spl-account-compression`:

```tsx
const treePublicKey = new PublicKey(assetData.compression.tree)

const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
	connection,
	treePublicKey
)
```

Крок четвертий є найскладнішим концептуально. Використовуючи три зібрані шматочки інформації, потрібно скласти шлях доказу для відповідного листа cNFT. Шлях доказу представлений як облікові записи, передані до програми як інструкція. Програма використовує кожну з адрес облікових записів як вузол доказу, щоб довести, що дані листа відповідають тому, що ви стверджуєте.

Повний доказ надається індексатором, як показано вище у `assetProof`. Однак ви можете виключити таку саму кількість облікових записів з кінця доказу, як глибина крони.

```tsx
const canopyDepth = treeAccount.getCanopyDepth() || 0

const proofPath: AccountMeta[] = assetProof.proof
	.map((node: string) => ({
	pubkey: new PublicKey(node),
	isSigner: false,
	isWritable: false
}))
.slice(0, assetProof.proof.length - canopyDepth)
```

Нарешті, ви можете зібрати інструкцію для передачі. Функція-помічник `createTransferInstruction` вимагає наступних аргументів:

- `accounts` — список облікових записів для інструкції, який включає наступне:  
  - `merkleTree` — обліковий запис дерева Меркла  
  - `treeAuthority` — авторитет дерева Меркла  
  - `leafOwner` — власник листа (cNFT), про який йде мова  
  - `leafDelegate` — делегат листа (cNFT); якщо делегата не додано, це має бути те ж саме, що й `leafOwner`  
  - `newLeafOwner` — адреса нового власника після передачі  
  - `logWrapper` — програма, яку слід використовувати для надання даних індексаторам через логи; це має бути адреса програми SPL Noop, якщо ви не використовуєте стороннє рішення  
  - `compressionProgram` — програма для компресії; це має бути адреса програми SPL State Compression, якщо ви не використовуєте стороннє рішення  
  - `anchorRemainingAccounts` — тут додається шлях доведення (proof path)  

- `args` — додаткові аргументи, необхідні для інструкції:  
  - `root` — кореневий вузол дерева Меркла з asset proof; надається індексатором як рядок і має бути спочатку конвертований у байти  
  - `dataHash` — хеш даних активу, отриманих від індексатора; надається індексатором як рядок і має бути спочатку конвертований у байти  
  - `creatorHash` — хеш творця cNFT, отриманий від індексатора; надається індексатором як рядок і має бути спочатку конвертований у байти  
  - `nonce` — використовується для забезпечення унікальності хешів листів; це значення має бути таким же, як `index`  
  - `index` — індекс, у якому розташований лист cNFT у дереві Меркла
    
Приклад цього показано нижче. Зверніть увагу, що перші три рядки коду отримують додаткову інформацію, вкладену в об'єкти, показані раніше, щоб вона була готова до використання під час складання самої інструкції.

```tsx
const treeAuthority = treeAccount.getAuthority()
const leafOwner = new PublicKey(assetData.ownership.owner)
const leafDelegate = assetData.ownership.delegate
	? new PublicKey(assetData.ownership.delegate)
	: leafOwner

const transferIx = createTransferInstruction(
	{
		merkleTree: treePublicKey,
		treeAuthority,
		leafOwner,
		leafDelegate,
		newLeafOwner: receiver,
		logWrapper: SPL_NOOP_PROGRAM_ID,
		compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
		anchorRemainingAccounts: proofPath,
	},
	{
		root: [...new PublicKey(assetProof.root.trim()).toBytes()],
		dataHash: [...new PublicKey(assetData.compression.data_hash.trim()).toBytes()],
		creatorHash: [
			...new PublicKey(assetData.compression.creator_hash.trim()).toBytes(),
		],
		nonce: assetData.compression.leaf_id,
		index: assetData.compression.leaf_id,
	}
)
```

## Висновки

Ми розглянули основні навички, необхідні для взаємодії з cNFT, але не охопили всі аспекти повністю. Ви також можете використовувати Bubblegum для виконання таких дій, як спалювання, перевірка, делегування тощо. Ми не будемо розглядати ці дії детально, але їхні інструкції схожі на процеси створення та передачі. Якщо вам потрібен цей додатковий функціонал, ознайомтеся з [вихідним кодом клієнта Bubblegum](https://github.com/metaplex-foundation/mpl-bubblegum/tree/main/clients/js-solita) і скористайтеся допоміжними функціями, які він надає.

Майте на увазі, що технологія компресії доволі нова. Доступні інструменти швидко розвиватимуться, але принципи, які ви вивчили в цьому уроці, ймовірно, залишаться незмінними. Ці принципи також можуть бути розширені на компресію довільного стану, тому переконайтеся, що ви засвоїли їх тут, щоб бути готовим до нових цікавих уроків у майбутньому!

# Лабораторна Робота

Давайте розпочнемо та попрактикуємося у створенні та роботі з cNFT. Разом ми напишемо максимально простий скрипт, який дозволить створити колекцію cNFT за допомогою дерева Меркля.

### 1. Візьміть стартовий код

Перш за все, клонуйте стартовий код з гілки `starter` нашого [репозиторію cNFT lab](https://github.com/Unboxed-Software/solana-cnft-demo).

`git clone https://github.com/Unboxed-Software/solana-cnft-demo.git`

`cd solana-cnft-demo`

`npm install`

Ознайомтеся зі стартовим кодом. Найважливіші — це допоміжні функції, розташовані в файлі `utils.ts`, а також URI, надані в файлі `uri.ts`.

Файл `uri.ts` містить 10 тис. URI, які ви можете використовувати для оф-чейн частини метаданих вашого NFT. Звісно, ви можете створювати свої власні метадані. Однак цей урок не спрямований на підготовку метаданих, тому ми надали деякі для вас.

Файл `utils.ts` містить кілька допоміжних функцій, щоб зменшити необхідність писати зайвий шаблонний код. Ось вони:

- `getOrCreateKeypair` — ця функція створить нову пару ключів для вас і збереже її у файлі `.env`, або, якщо вже є приватний ключ у файлі `.env`, ініціалізує пару ключів з цього значення.  
- `airdropSolIfNeeded` — ця функція надасть певну кількість SOL на зазначену адресу в Devnet, якщо баланс цієї адреси буде нижчим за 1 SOL.  
- `createNftMetadata` — ця функція створить метадані для NFT, використовуючи публічний ключ творця та індекс. Метадані є фіктивними і використовують URI, що відповідає зазначеному індексу зі списку `uri.ts`.
- `getOrCreateCollectionNFT` — ця функція перевірить, чи існує колекція NFT за адресою, зазначеною в `.env`. Якщо ні, функція створить нову колекцію NFT і додасть її адресу в `.env`.

Нарешті, в `index.ts` є деякий шаблонний код, який створює нове з'єднання з Devnet, викликає `getOrCreateKeypair` для ініціалізації "гаманця" і викликає `airdropSolIfNeeded`, щоб профінансувати гаманець, якщо його баланс низький.

Весь наш код ми будемо писати в `index.ts`.

### 2. Створення облікового запису Merkle дерева

Ми почнемо зі створення облікового запису Merkle дерева. Давайте інкапсулюємо це в функцію, яка зрештою створить *і* ініціалізує обліковий запис. Ми розмістимо її під нашою функцією `main` в `index.ts`. Назвемо її `createAndInitializeTree`. Для того, щоб ця функція працювала, їй будуть потрібні наступні параметри:

- `connection` - підключення `Connection`, яке буде використовуватися для взаємодії з мережею.
- `payer` - `Keypair`, який буде оплачувати транзакції.
- `maxDepthSizePair` - `ValidDepthSizePair`. Цей тип походить з `@solana/spl-account-compression`. Це простий об'єкт з властивостями `maxDepth` та `maxBufferSize`, який забезпечує правильну комбінацію цих двох значень.
- `canopyDepth` - число, що вказує глибину крони

    В середині функції ми згенеруємо нову адресу для дерева, а потім створимо інструкцію для виділення нової акаунта для Merkle дерева, викликавши `createAllocTreeIx` з `@solana/spl-account-compression`.

```tsx
async function createAndInitializeTree(
  connection: Connection,
  payer: Keypair,
  maxDepthSizePair: ValidDepthSizePair,
  canopyDepth: number
) {
	const treeKeypair = Keypair.generate()

	const allocTreeIx = await createAllocTreeIx(
    connection,
    treeKeypair.publicKey,
    payer.publicKey,
    maxDepthSizePair,
    canopyDepth
  )
}
```

### 3. Використання Bubblegum для ініціалізації дерева Меркла та створення облікового запису конфігурації дерева

Маючи готову інструкцію для створення дерева, ми можемо створити інструкцію для виклику `create_tree` у програмі Bubblegum. Це ініціалізує обліковий запис дерева Merkle *і* створить новий обліковий запис конфігурації дерева у програмі Bubblegum.

Ця інструкція потребує від нас наступних даних:

- `accounts` - об'єкт необхідних облікових записів; це включає:
    - `treeAuthority` - це має бути PDA, отриманий за адресою Merkle дерева та програмою Bubblegum
    - `merkleTree` - адреса Merkle дерева
    - `payer` - платник комісії
    - `treeCreator` - адреса творця дерева; зробимо її такою ж, як і `payer`
    - `logWrapper` - зробіть це `SPL_NOOP_PROGRAM_ID`
    - `compressionProgram` - зробіть це `SPL_ACCOUNT_COMPRESSION_PROGRAM_ID`
- `args` - список аргументів інструкції; це включає:
    - `maxBufferSize` - розмір буфера з параметра `maxDepthSizePair` нашої функції
    - `maxDepth` - максимальна глибина з параметра `maxDepthSizePair` нашої функції
    - `public` - чи має дерево бути публічним; встановимо значення `false`

Нарешті, ми можемо додати обидві інструкції до транзакції і відправити транзакцію. Майте на увазі, що транзакція має бути підписана як `payer`, так і `treeKeypair`.

```tsx
async function createAndInitializeTree(
  connection: Connection,
  payer: Keypair,
  maxDepthSizePair: ValidDepthSizePair,
  canopyDepth: number
) {
	const treeKeypair = Keypair.generate()

	const allocTreeIx = await createAllocTreeIx(
    connection,
    treeKeypair.publicKey,
    payer.publicKey,
    maxDepthSizePair,
    canopyDepth
  )

	const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(
    [treeKeypair.publicKey.toBuffer()],
    BUBBLEGUM_PROGRAM_ID
  )

	const createTreeIx = createCreateTreeInstruction(
    {
      treeAuthority,
      merkleTree: treeKeypair.publicKey,
      payer: payer.publicKey,
      treeCreator: payer.publicKey,
      logWrapper: SPL_NOOP_PROGRAM_ID,
      compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
    },
    {
      maxBufferSize: maxDepthSizePair.maxBufferSize,
      maxDepth: maxDepthSizePair.maxDepth,
      public: false,
    }
  )

	const tx = new Transaction().add(allocTreeIx, createTreeIx)
  tx.feePayer = payer.publicKey
  
  try {
    const txSignature = await sendAndConfirmTransaction(
      connection,
      tx,
      [treeKeypair, payer],
      {
        commitment: "confirmed",
        skipPreflight: true,
      }
    )

    console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)

    console.log("Tree Address:", treeKeypair.publicKey.toBase58())

    return treeKeypair.publicKey
  } catch (err: any) {
    console.error("\nFailed to create Merkle tree:", err)
    throw err
  }
}
```

Якщо ви хочете протестувати те, що ви вже зробили, не соромтесь викликати функцію `createAndInitializeTree` з функції `main` і передати малі значення для максимальної глибини та максимального розміру буфера.

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )
}
```

Майте на увазі, що Devnet SOL має обмеження, тому якщо ви тестуватимете занадто часто, ви можете вичерпати баланс Devnet SOL до того, як дійдемо до етапу мінту. Для тестування виконайте наступну команду в терміналі:

`npm run start`

### 4. Мінт cNFT у вашому дереві

Повірте, це все, що потрібно для налаштування вашого дерева для стиснутих NFT! Тепер приділимо увагу мінту.

Спочатку додамо функцію під назвою `mintCompressedNftToCollection`. Для цієї функції будуть потрібні наступні параметри:

- `connection` - з'єднання `Connection`, яке використовується для взаємодії з мережею.
- `payer` - `Keypair`, який буде платити за транзакції.
- `treeAddress` - адреса Merkle дерева.
- `collectionDetails` - деталі колекції типу `CollectionDetails` з файлу `utils.ts`.
- `amount` - кількість cNFT, яку потрібно мінтити.
  
Тіло цієї функції виконуватиме наступні кроки:

1. Отримає авторизацію дерева (tree authority), як і раніше. Це буде PDA, отриманий з адреси Merkle дерева та програми Bubblegum.
2. Отримає `bubblegumSigner`. Це PDA, яка генерується з рядка `"collection_cpi"` та програми Bubblegum і є необхідною для мінта в колекцію.
3. Створить метадані для cNFT, викликавши функцію `createNftMetadata` з файлу `utils.ts`.
4. Створить інструкцію для мінта, викликавши функцію `createMintToCollectionV1Instruction` з SDK Bubblegum.
5. Побудує та надішле транзакцію з інструкцією мінта.
6. Повторить кроки 3-6, поки не змінтить потрібну кількість cNFT, визначену параметром `amount`.
   
`createMintToCollectionV1Instruction` приймає два аргументи: `accounts` та `args`. Останній — це просто метадані NFT. Як і з усіма складними інструкціями, основною проблемою є визначення правильних рахунків, які потрібно надати. Давайте швидко пройдемося по них:

- `payer` - рахунок, який буде оплачувати збори за транзакції, оренду тощо.
- `merkleTree` - рахунок Меркле-дерева.
- `treeAuthority` - авторитет дерева; має бути тим самим PDA, який ви отримали раніше.
- `treeDelegate` - делегат дерева; зазвичай це те саме, що й творець дерева.
- `leafOwner` - бажаний власник стиснутого NFT, який буде мінтити.
- `leafDelegate` - бажаний делегат стиснутого NFT, який буде мінтити; зазвичай це те саме, що й власник листа.
- `collectionAuthority` - авторитет колекції NFT.
- `collectionAuthorityRecordPda` - необов'язковий PDA запису авторитету колекції; зазвичай його немає, у такому випадку потрібно використовувати адресу програми Bubblegum.
- `collectionMint` - рахунок мінта для колекції NFT.
- `collectionMetadata` - рахунок метаданих для колекції NFT.
- `editionAccount` - рахунок майстер-видання для колекції NFT.
- `compressionProgram` - програма стиснення, яку потрібно використовувати; це має бути адреса програми SPL State Compression, якщо у вас немає іншої кастомної реалізації.
- `logWrapper` - програма, яка буде використовуватися для виведення даних для індексаторів через логи; це має бути адреса програми SPL Noop, якщо у вас немає іншої кастомної реалізації.
- `bubblegumSigner` - PDA, який використовує програма Bubblegum для перевірки колекції.
- `tokenMetadataProgram` - програма метаданих токенів, яка використовувалась для колекції NFT; зазвичай це програма Metaplex Token Metadata.
  
Коли ви складете все це разом, це буде виглядати так:

```tsx
async function mintCompressedNftToCollection(
  connection: Connection,
  payer: Keypair,
  treeAddress: PublicKey,
  collectionDetails: CollectionDetails,
  amount: number
) {
  // Derive the tree authority PDA ('TreeConfig' account for the tree account)
  const [treeAuthority] = PublicKey.findProgramAddressSync(
    [treeAddress.toBuffer()],
    BUBBLEGUM_PROGRAM_ID
  )

  // Derive the bubblegum signer, used by the Bubblegum program to handle "collection verification"
  // Only used for `createMintToCollectionV1` instruction
  const [bubblegumSigner] = PublicKey.findProgramAddressSync(
    [Buffer.from("collection_cpi", "utf8")],
    BUBBLEGUM_PROGRAM_ID
  )

  for (let i = 0; i < amount; i++) {
    // Compressed NFT Metadata
    const compressedNFTMetadata = createNftMetadata(payer.publicKey, i)

    // Create the instruction to "mint" the compressed NFT to the tree
    const mintIx = createMintToCollectionV1Instruction(
      {
        payer: payer.publicKey, // The account that will pay for the transaction
        merkleTree: treeAddress, // The address of the tree account
        treeAuthority, // The authority of the tree account, should be a PDA derived from the tree account address
        treeDelegate: payer.publicKey, // The delegate of the tree account, should be the same as the tree creator by default
        leafOwner: payer.publicKey, // The owner of the compressed NFT being minted to the tree
        leafDelegate: payer.publicKey, // The delegate of the compressed NFT being minted to the tree
        collectionAuthority: payer.publicKey, // The authority of the "collection" NFT
        collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID, // Must be the Bubblegum program id
        collectionMint: collectionDetails.mint, // The mint of the "collection" NFT
        collectionMetadata: collectionDetails.metadata, // The metadata of the "collection" NFT
        editionAccount: collectionDetails.masterEditionAccount, // The master edition of the "collection" NFT
        compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        logWrapper: SPL_NOOP_PROGRAM_ID,
        bubblegumSigner,
        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,
      },
      {
        metadataArgs: Object.assign(compressedNFTMetadata, {
          collection: { key: collectionDetails.mint, verified: false },
        }),
      }
    )

    try {
      // Create new transaction and add the instruction
      const tx = new Transaction().add(mintIx)

      // Set the fee payer for the transaction
      tx.feePayer = payer.publicKey

      // Send the transaction
      const txSignature = await sendAndConfirmTransaction(
        connection,
        tx,
        [payer],
        { commitment: "confirmed", skipPreflight: true }
      )

      console.log(
        `https://explorer.solana.com/tx/${txSignature}?cluster=devnet`
      )
    } catch (err) {
      console.error("\nFailed to mint compressed NFT:", err)
      throw err
    }
  }
}
```

Це чудовий момент для тестування з маленьким деревом. Просто оновіть функцію `main`, щоб викликати `getOrCreateCollectionNFT`, а потім `mintCompressedNftToCollection`:

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )

  const collectionNft = await getOrCreateCollectionNFT(connection, wallet)

  await mintCompressedNftToCollection(
    connection,
    wallet,
    treeAddress,
    collectionNft,
    2 ** maxDepthSizePair.maxDepth
  )
}
```

Щоб запустити, у вашому терміналі введіть: `npm run start`

### 5. Читання існуючих даних cNFT 

Тепер, коли ми написали код для створення cNFT, давайте подивимося, чи можемо ми фактично отримати їх дані. Це складно, оскільки ончейн дані — це лише рахунок Меркле-дерева, інформація з якого може бути використана для перевірки правильності існуючих даних, але не дає безпосереднього доступу до самих даних.

Давайте почнемо з оголошення функції `logNftDetails`, яка прийматиме параметри `treeAddress` та `nftsMinted`.

На цьому етапі у нас немає безпосереднього ідентифікатора для нашого cNFT. Щоб отримати цей ідентифікатор, нам потрібно знати індекс листа, який був використаний під час мінта cNFT. Потім ми можемо використати цей індекс для отримання ID активу за допомогою Read API, а після цього використовувати Read API для отримання даних cNFT.

У нашому випадку ми створили непублічне дерево та випустили 8 cNFT, тому ми знаємо, що індекси листочків, які використовувалися, були 0-7. Використовуючи це, ми можемо застосувати функцію `getLeafAssetId` з бібліотеки `@metaplex-foundation/mpl-bubblegum` для отримання ID активу.

Нарешті, ми можемо використати RPC, який підтримує [Read API](https://docs.solana.com/developing/guides/compressed-nfts#reading-compressed-nfts-metadata) для отримання активу. Ми використовуватимемо [Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), але ви можете вибрати будь-якого іншого провайдера RPC. Щоб використовувати Helius, вам потрібно отримати безкоштовний API ключ на [їхньому сайті](https://dev.helius.xyz/). Потім додайте `RPC_URL` до вашого файлу `.env`, наприклад:

```bash
# Add this
RPC_URL=https://devnet.helius-rpc.com/?api-key=YOUR_API_KEY
```

Тоді просто виконайте POST-запит до наданого вами RPC URL і помістіть інформацію `getAsset` у тіло запиту:

```tsx
async function logNftDetails(treeAddress: PublicKey, nftsMinted: number) {
  for (let i = 0; i < nftsMinted; i++) {
    const assetId = await getLeafAssetId(treeAddress, new BN(i))
    console.log("Asset ID:", assetId.toBase58())
    const response = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const { result } = await response.json()
    console.log(JSON.stringify(result, null, 2))
  }
}
```

Helius фактично спостерігає за журналами транзакцій у режимі реального часу та зберігає метадані NFT, які були захешовані та збережені в дереві Меркла. Це дозволяє їм надавати ці дані за запитом.  

Якщо додати виклик цієї функції наприкінці `main` і повторно запустити скрипт, дані, які ми отримаємо в консолі, будуть дуже детальними. Вони включають всю інформацію, яку ви очікуєте знайти як в ончейн, так і в офчейн частині традиційного NFT. Ви зможете знайти атрибути cNFT, файли, інформацію про власність і творців та багато іншого.

```json
{
  "interface": "V1_NFT",
  "id": "48Bw561h1fGFK4JGPXnmksHp2fpniEL7hefEc6uLZPWN",
  "content": {
    "$schema": "https://schema.metaplex.com/nft1.0.json",
    "json_uri": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.json",
    "files": [
      {
        "uri": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png",
        "cdn_uri": "https://cdn.helius-rpc.com/cdn-cgi/image//https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png",
        "mime": "image/png"
      }
    ],
    "metadata": {
      "attributes": [
        {
          "value": "183",
          "trait_type": "R"
        },
        {
          "value": "89",
          "trait_type": "G"
        },
        {
          "value": "78",
          "trait_type": "B"
        }
      ],
      "description": "Random RGB Color",
      "name": "CNFT",
      "symbol": "CNFT"
    },
    "links": {
      "image": "https://raw.githubusercontent.com/Unboxed-Software/rgb-png-generator/master/assets/183_89_78/183_89_78.png"
    }
  },
  "authorities": [
    {
      "address": "DeogHav5T2UV1zf5XuH4DTwwE5fZZt7Z4evytUUtDtHd",
      "scopes": [
        "full"
      ]
    }
  ],
  "compression": {
    "eligible": false,
    "compressed": true,
    "data_hash": "3RsXHMBDpUPojPLZuMyKgZ1kbhW81YSY3PYmPZhbAx8K",
    "creator_hash": "Di6ufEixhht76sxutC9528H7PaWuPz9hqTaCiQxoFdr",
    "asset_hash": "2TwWjQPdGc5oVripPRCazGBpAyC5Ar1cia8YKUERDepE",
    "tree": "7Ge8nhDv2FcmnpyfvuWPnawxquS6gSidum38oq91Q7vE",
    "seq": 8,
    "leaf_id": 7
  },
  "grouping": [
    {
      "group_key": "collection",
      "group_value": "9p2RqBUAadMznAFiBEawMJnKR9EkFV98wKgwAz8nxLmj"
    }
  ],
  "royalty": {
    "royalty_model": "creators",
    "target": null,
    "percent": 0,
    "basis_points": 0,
    "primary_sale_happened": false,
    "locked": false
  },
  "creators": [
    {
      "address": "HASk3AoTPAvC1KnXSo6Qm73zpkEtEhbmjLpXLgvyKBkR",
      "share": 100,
      "verified": false
    }
  ],
  "ownership": {
    "frozen": false,
    "delegated": false,
    "delegate": null,
    "ownership_model": "single",
    "owner": "HASk3AoTPAvC1KnXSo6Qm73zpkEtEhbmjLpXLgvyKBkR"
  },
  "supply": {
    "print_max_supply": 0,
    "print_current_supply": 0,
    "edition_nonce": 0
  },
  "mutable": false,
  "burnt": false
}
```

Пам’ятайте, що Read API також включає способи отримання декількох активів, запити за власником, творцем тощо. Обов’язково перегляньте [документацію Helius](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api), щоб дізнатися, які можливості доступні.

### 6. Передача cNFT

Останнє, що ми додамо до нашого скрипта, це cNFT transfer. Як і у випадку зі стандартною передачею токенів SPL, безпека має першочергове значення. Однак, на відміну від стандартної передачі токенів SPL, для створення безпечної передачі з будь-яким типом компресії програмі, яка виконує передачу, необхідно надати всі дані активу.

Програма, у цьому випадку Bubblegum, повинна отримати всі дані, які були захешовані й збережені у відповідному вузлі, *та* має отримати "proof path (щлях доказу)" для цього вузла. Це робить передачу cNFT трохи складнішою, ніж передачу токенів SPL.

Запам’ятайте, загальні кроки такі:

1. Отримати дані активу cNFT з індексатора  
2. Отримати доказ cNFT з індексатора  
3. Отримати обліковий запис дерева Меркла з блокчейну Solana  
4. Підготувати доказ активу у вигляді списку об’єктів `AccountMeta`  
5. Створити та відправити інструкцію передачі Bubblegum
   
Почнемо з функції `transferNft`, яка приймає такі параметри:

- `connection` — об'єкт `Connection`  
- `assetId` — об'єкт `PublicKey`  
- `sender` — об'єкт `Keypair`, щоб ми могли підписати транзакцію  
- `receiver` — об'єкт `PublicKey`, що представляє нового власника
  
Всередині цієї функції повторно отримаємо дані активу, а також отримаємо доказ активу. Для надійності обгорнімо все у блок `try catch`.

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    const assetDataResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const assetData = (await assetDataResponse.json()).result

    const assetProofResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetProof",
        params: {
          id: assetId,
        },
      }),
    })
    const assetProof = (await assetProofResponse.json()).result
	} catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
	}
}
```

Далі отримаємо обліковий запис дерева Меркла з блокчейна, визначимо глибину крони (canopy depth) і зберемо шлях доказу. Для цього перетворимо доказ активу, отриманий від Helius, у список об’єктів `AccountMeta`, а потім видалимо всі вузли доказу в кінці, які вже кешовані на блокчейні в кроні.

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    ...

    const treePublicKey = new PublicKey(assetData.compression.tree)

    const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
      connection,
      treePublicKey
    )

    const canopyDepth = treeAccount.getCanopyDepth() || 0

    const proofPath: AccountMeta[] = assetProof.proof
      .map((node: string) => ({
        pubkey: new PublicKey(node),
        isSigner: false,
        isWritable: false,
      }))
      .slice(0, assetProof.proof.length - canopyDepth)
  } catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
  }
}
```

Нарешті, ми будуємо інструкцію за допомогою `createTransferInstruction`, додаємо її до транзакції, потім підписуємо і відправляємо транзакцію. Ось як виглядатиме вся функція `transferNft`, коли вона буде завершена:

```tsx
async function transferNft(
  connection: Connection,
  assetId: PublicKey,
  sender: Keypair,
  receiver: PublicKey
) {
  try {
    const assetDataResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: {
          id: assetId,
        },
      }),
    })
    const assetData = (await assetDataResponse.json()).result

    const assetProofResponse = await fetch(process.env.RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetProof",
        params: {
          id: assetId,
        },
      }),
    })
    const assetProof = (await assetProofResponse.json()).result

    const treePublicKey = new PublicKey(assetData.compression.tree)

    const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(
      connection,
      treePublicKey
    )

    const canopyDepth = treeAccount.getCanopyDepth() || 0

    const proofPath: AccountMeta[] = assetProof.proof
      .map((node: string) => ({
        pubkey: new PublicKey(node),
        isSigner: false,
        isWritable: false,
      }))
      .slice(0, assetProof.proof.length - canopyDepth)

    const treeAuthority = treeAccount.getAuthority()
    const leafOwner = new PublicKey(assetData.ownership.owner)
    const leafDelegate = assetData.ownership.delegate
      ? new PublicKey(assetData.ownership.delegate)
      : leafOwner

    const transferIx = createTransferInstruction(
      {
        merkleTree: treePublicKey,
        treeAuthority,
        leafOwner,
        leafDelegate,
        newLeafOwner: receiver,
        logWrapper: SPL_NOOP_PROGRAM_ID,
        compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        anchorRemainingAccounts: proofPath,
      },
      {
        root: [...new PublicKey(assetProof.root.trim()).toBytes()],
        dataHash: [
          ...new PublicKey(assetData.compression.data_hash.trim()).toBytes(),
        ],
        creatorHash: [
          ...new PublicKey(assetData.compression.creator_hash.trim()).toBytes(),
        ],
        nonce: assetData.compression.leaf_id,
        index: assetData.compression.leaf_id,
      }
    )

    const tx = new Transaction().add(transferIx)
    tx.feePayer = sender.publicKey
    const txSignature = await sendAndConfirmTransaction(
      connection,
      tx,
      [sender],
      {
        commitment: "confirmed",
        skipPreflight: true,
      }
    )
    console.log(`https://explorer.solana.com/tx/${txSignature}?cluster=devnet`)
  } catch (err: any) {
    console.error("\nFailed to transfer nft:", err)
    throw err
  }
}
```
Давайте передамо наш перший стиснутий NFT з індексом 0 іншій особі. Спочатку нам потрібно створити інший гаманець з коштами, потім отримати assetID на індексі 0 за допомогою `getLeafAssetId`. Потім ми здійснимо передачу. І в кінці виведемо всю колекцію за допомогою нашої функції `logNftDetails`. Ви помітите, що NFT з індексом 0 тепер буде належати нашому новому гаманцю в полі `ownership`.

```tsx
async function main() {
  const connection = new Connection(clusterApiUrl("devnet"), "confirmed")
  const wallet = await getOrCreateKeypair("Wallet_1")
  await airdropSolIfNeeded(wallet.publicKey)

  const maxDepthSizePair: ValidDepthSizePair = {
    maxDepth: 3,
    maxBufferSize: 8,
  }

  const canopyDepth = 0

  const treeAddress = await createAndInitializeTree(
    connection,
    wallet,
    maxDepthSizePair,
    canopyDepth
  )

  const collectionNft = await getOrCreateCollectionNFT(connection, wallet)

  await mintCompressedNftToCollection(
    connection,
    wallet,
    treeAddress,
    collectionNft,
    2 ** maxDepthSizePair.maxDepth
  )

  const recieverWallet = await getOrCreateKeypair("Wallet_2")
  const assetId = await getLeafAssetId(treeAddress, new BN(0))
  await airdropSolIfNeeded(recieverWallet.publicKey)

  console.log(`Transfering ${assetId.toString()} from ${wallet.publicKey.toString()} to ${recieverWallet.publicKey.toString()}`)

  await transferNft(
    connection,
    assetId,
    wallet,
    recieverWallet.publicKey
  )

  await logNftDetails(treeAddress, 8)
}
```

Запустіть свій скрипт. Все повинно виконатися без помилок, і все це за майже 0.01 SOL!

Вітаємо! Тепер ви знаєте, як створювати, зчитувати і передавати стиснуті NFT (cNFT). Якщо хочете, ви можете оновити максимальну глибину, максимальний розмір буфера та глибину крони до більших значень, і якщо у вас буде достатньо SOL на Devnet, цей скрипт дозволить вам створити до 10 000 cNFT за малу частину від вартості створення 10 000 традиційних NFT (Примітка: якщо ви плануєте створити велику кількість NFT, можливо, вам варто спробувати обробити ці інструкції групами для зменшення загальної кількості транзакцій).

Якщо вам потрібно більше часу для роботи з цією лабораторною, не соромтеся пройти її ще раз або подивитися код рішення на гілці `solution` репозиторію [lab repo](https://github.com/Unboxed-Software/solana-cnft-demo/tree/solution).

## Завдання

Тепер ваша черга спробувати ці концепції на практиці! Ми не будемо давати надто суворих вказівок, але ось кілька ідей:

1. Створіть свою власну продукційну колекцію cNFT.
2. Розробіть інтерфейс, який дозволить вам створювати cNFT і відображати його.
3. Спробуйте відтворити деякі функції зі скрипту лабораторної в смарт-контракті, тобто напишіть програму, яка може створювати cNFT.

## Закінчили лабораторну роботу?

Запуште свій код на GitHub і [розкажіть нам, що ви думаєте про цей урок](https://form.typeform.com/to/IPH0UGz7#answers-lesson=db156789-2400-4972-904f-40375582384a)!
