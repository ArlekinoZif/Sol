---
заголовок: Десеріалізація Даних Програми  
цілі:  
- Пояснити Програмно Похідні Акаунти (PDA)  
- Отримати PDA на основі заданих seed  
- Отримати акаунти програми  
- Використовувати Borsh для десеріалізації користувацьких даних  
---

# Стислий огляд

- Програми зберігають дані в PDA, що означає **Програмно Похідна Адреса** (Program Derived Address).  
- PDA не мають відповідного секретного ключа.  
- Щоб зберігати та знаходити дані, необхідно отримати PDA за допомогою методу `findProgramAddress(seeds, programid)`.  
- Ви можете отримати акаунти, що належать програмі, використовуючи `getProgramAccounts(programId)`.  
- Дані акаунтів потрібно десеріалізувати за тим самим макетом, який використовувався для їхнього зберігання. Для цього можна використовувати бібліотеку `@coral-xyz/borsh` для створення схеми.  

# Урок

У попередньому уроці ми серіалізували дані програми, які згодом були збережені в блокчейні програмою Solana. У цьому уроці ми детальніше розглянемо, як програми зберігають дані в блокчейні, як отримати ці дані та як десеріалізувати їх.

## Програми

Часто кажуть, що у Solana все є акаунтом. Навіть програми. Програми — це акаунти, які зберігають код і позначені як виконувані (executable). Цей код може бути виконаний на Solana за вказівкою. Адреса програми є публічним ключем на еліптичній кривій Ed25519. Як і всі публічні ключі, вони мають відповідні секретні ключі.

Програми зберігають дані окремо від свого коду. Дані програм зберігаються у **PDA (Program Derived Address)** — програмах, які використовують адреси, отримані з певних параметрів. PDA — це унікальне поняття для Solana, але шаблон цілком знайомий: 

- PDA можна уявити як сховище ключів і значень, де адреса є ключем, а дані всередині акаунту — значенням.  
- Також PDA можна розглядати як записи в базі даних, де адреса виступає як первинний ключ, який використовується для пошуку значень всередині.

PDA поєднують адресу програми та обрані розробником seeds (початкові значення) для створення адрес, які зберігають окремі частини даних. Оскільки PDA є адресами, що лежать **поза** еліптичною кривою Ed25519, вони не мають секретних ключів. Натомість адреса програми, яка їх створила може підписатися замість PDA.

PDA та дані всередині них можна стабільно знаходити на основі адреси програми, bump і seeds. Щоб знайти PDA, програмний ідентифікатор (program ID) і вибрані розробником seeds (наприклад, текстовий рядок) передаються через функцію [`findProgramAddress()`](https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html#findProgramAddress).  

Розгляньмо кілька прикладів...

#### Приклад: програма з глобальним станом  

Проста програма, яка має глобальний стан, наприклад, наш ping лічильник, може використовувати лише один PDA, заснований на простій seed-фразі, як-от `"GLOBAL_STATE"`. Якщо клієнт хоче читати дані з цього PDA, він може отримати адресу, використовуючи програмний ідентифікатор (program ID) та цей самий seed.

```typescript
const [pda, bump] = await findProgramAddress(Buffer.from("GLOBAL_STATE"), programId)
```

![Global state using a PDA](../../assets/pdas-global-state.svg)

#### Приклад: програма з даними користувача  

У програмах, які зберігають дані користувача, зазвичай використовується публічний ключ користувача як seed. Це розділяє дані кожного користувача у власний PDA. Таке розділення дозволяє клієнту знайти дані кожного користувача, визначивши адресу за допомогою програмного ідентифікатора (program ID) і публічного ключа користувача.

```typescript
const [pda, bump] = await web3.PublicKey.findProgramAddress(
  [
    publicKey.toBuffer()
  ],
  programId
)
```

![Per user state](../../assets/pdas-per-user-state.svg)
### Приклад: програма з кількома елементами даних на одного користувача  

Якщо у користувача є кілька елементів даних, програма може використовувати більше seed для створення та ідентифікації облікових записів. Наприклад, у додатку для ведення нотаток може бути один обліковий запис на кожну нотатку, де кожен PDA визначається за допомогою публічного ключа користувача та назви нотатки.

```typescript
const [pda, bump] = await web3.PublicKey.findProgramAddress(
  [
    publicKey.toBuffer(), 
    Buffer.from("Shopping list")
  ],
  programId,
);
```

![Global state using a PDA](../../assets/pdas-note-taking-program.svg)

У цьому прикладі ми бачимо, що і в Еліс, і в Боба є нотатка з назвою "Shopping List" (Список покупок), але завдяки використанню їхніх адрес гаманців як одного з seed, обидві ці нотатки можуть існувати одночасно.

### Отримання кількох акаунтів

Окрім обчислення адрес, ви можете отримати всі акаунти, створені програмою, за допомогою методу `connection.getProgramAccounts(programId)`. Цей метод повертає масив об'єктів, де кожен об'єкт має властивість `pubkey`, яка представляє публічний ключ акаунта, і властивість `account` типу `AccountInfo`. Ви можете використовувати властивість `account` для отримання даних акаунта.

```typescript
const accounts = connection.getProgramAccounts(programId).then(accounts => {
  accounts.map(({ pubkey, account }) => {
    console.log('Account:', pubkey)
    console.log('Data buffer:', account.data)
  })
})
```

## Десеріалізація даних програми

Атрибут `data` в об'єкті `AccountInfo` є буфером. Щоб ефективно його використовувати, необхідно написати код, який десеріалізує ці дані у більш зручний для роботи формат. Це схоже на процес серіалізації, який ми розглядали у попередньому уроці. Як і раніше, ми будемо використовувати [Borsh](https://borsh.io/) та пакет `@coral-xyz/borsh`. Якщо вам потрібно пригадати ці інструменти, перегляньте попередній урок.

Для десеріалізації потрібно заздалегідь знати структуру акаунту. Створюючи власні програми, ви визначаєте, як це буде зроблено в процесі розробки. Багато програм також мають документацію про те, як десеріалізувати дані акаунта. В іншому випадку, якщо код програми доступний, ви можете переглянути джерело і визначити структуру даних таким чином.

Щоб правильно десеріалізувати дані з ончейн-програми, необхідно створити схему на стороні клієнта, яка відображає, як дані зберігаються в акаунті. Наприклад, ось приклад схеми для акаунта, що зберігає метадані про гравця в ончейн-грі.

```typescript
import * as borsh from "@coral-xyz/borsh";

borshAccountSchema = borsh.struct([
  borsh.bool("initialized"),
  borsh.u16("playerId"),
  borsh.str("name"),
]);

```

Як тільки ви визначили свою схему, просто викликайте `.decode(buffer)` на схемі.

```typescript
import * as borsh from "@coral-xyz/borsh";

borshAccountSchema = borsh.struct([
  borsh.bool("initialized"),
  borsh.u16("playerId"),
  borsh.str("name"),
]);

const { playerId, name } = borshAccountSchema.decode(buffer);

```

# Лабораторна робота

Давайте разом попрактикуємося, використовуючи додаток Movie Review з останнього уроку. Не хвилюйтеся, якщо ви тільки зараз приєдналися до цього уроку — ви все одно зможете слідкувати за поясненнями.

Нагадаю, цей проект використовує програму Solana, розгорнуту на Devnet, яка дозволяє користувачам залишати відгуки про фільми. У минулому уроці ми додали функціональність до каркасу інтерфейсу, дозволяючи користувачам подавати відгуки про фільми, але список відгуків все ще показує фіктивні дані. Давайте виправимо це, отримавши акаунти програми та десеріалізувавши дані, що зберігаються там.

![movie review frontend](../assets/movie-reviews-frontend.png)

### 1. Завантажте початковий код

Якщо ви не завершили лабораторну роботу з минулого уроку або хочете переконатися, що нічого не пропустили, ви можете завантажити [початковий код](https://github.com/Unboxed-Software/solana-movie-frontend/tree/solution-serialize-instruction-data).

Проект — це досить проста програма на Next.js. Вона містить:

- `WalletContextProvider`, який ми створили на уроці про гаманці.
- Компонент `Card` для відображення відгуку про фільм.
- Компонент `MovieList`, який відображає відгуки у списку.
- Компонент `Form` для подачі нового відгуку.
- Файл `Movie.ts`, що містить визначення класу для об'єкта `Movie`.

Зверніть увагу, що коли ви запускаєте команду `npm run dev`, відгуки, що відображаються на сторінці, є фіктивними. Ми замінимо їх на реальні.

### 2. Створення буферної структури

Пам'ятайте, що для правильної взаємодії з програмою Solana, вам потрібно знати, як її дані структуровані. Нагадуємо:

![Ed25519 curve showing Movie Review Program](../assets/movie-review-program.svg)

Дані програми (частини, що виконується) зберігаються в програмному акаунті, але окремі відгуки зберігаються в PDA. Ми використовуємо `findProgramAddress()`, щоб створити PDA, унікальний для кожного гаманця та кожного фільму. Ми збережемо наступні дані в `data` акаунту PDA:

1. `initialized` як булевий тип, що представляє, чи ініціалізований акаунт.
2. `rating` як беззнакове ціле число, 8 біт, що представляє 5-бальний рейтинг фільму.
3. `title` як рядок, що представляє назву фільму, що рецензується.
4. `description` як рядок, що містить написану частину відгуку.

Налаштуємо схему `borsh` в класі `Movie`, щоб представити структуру даних акаунта фільму. Почнемо з імпорту `@coral-xyz/borsh`. Далі створимо статичну властивість `borshAccountSchema` та налаштуємо її на відповідну структуру `borsh`, що містить зазначені властивості.

```tsx
import * as borsh from '@coral-xyz/borsh'

export class Movie {
  title: string;
  rating: number;
  description: string;

  ...

  static borshAccountSchema = borsh.struct([
    borsh.bool('initialized'),
    borsh.u8('rating'),
    borsh.str('title'),
    borsh.str('description'),
  ])
}
```

Пам'ятайте, що порядок тут *має значення*. Він має співпадати з тим, як структуровані дані акаунта.
### 3. Створіть метод для десеріалізації даних

Тепер, коли ми налаштували структуру буфера, давайте створимо статичний метод в класі `Movie` під назвою `deserialize`, який прийматиме необов'язковий параметр `Buffer` і повертатиме об'єкт `Movie` або `null`.

```typescript
import * as borsh from '@coral-xyz/borsh'

export class Movie {
  title: string;
  rating: number;
  description: string;

  ...

  static borshAccountSchema = borsh.struct([
    borsh.bool('initialized'),
    borsh.u8('rating'),
    borsh.str('title'),
    borsh.str('description'),
  ])

  static deserialize(buffer?: Buffer): Movie|null {
    if (!buffer) {
      return null
    }

    try {
      const { title, rating, description } = this.borshAccountSchema.decode(buffer)
      return new Movie(title, rating, description)
    } catch(error) {
      console.log('Deserialization error:', error)
      return null
    }
  }
}
```

Метод спочатку перевіряє, чи існує буфер, і повертає `null`, якщо його немає. Далі він використовує створену структуру для декодування буфера, а потім використовує ці дані для створення та повернення екземпляра класу `Movie`. Якщо декодування не вдається, метод виводить помилку в консоль і повертає `null`.

### 4. Отримати акаунти

Тепер, коли ми налаштували десеріалізацію даних акаунтів, нам потрібно фактично отримати ці акаунти. Відкрийте файл `MovieList.tsx` і імпортуйте `@solana/web3.js`. Потім створіть нове з'єднання `Connection` всередині компонента `MovieList`. Нарешті, замініть рядок `setMovies(Movie.mocks)` всередині хука `useEffect` на виклик `connection.getProgramAccounts`. Отриманий масив перетворіть на масив фільмів і викликайте `setMovies`, щоб оновити стан.

```tsx
import { Card } from './Card'
import { FC, useEffect, useState } from 'react'
import { Movie } from '../models/Movie'
import * as web3 from '@solana/web3.js'
import { useConnection } from "@solana/wallet-adapter-react"

const MOVIE_REVIEW_PROGRAM_ID = 'CenYq6bDRB7p73EjsPEpiYN7uveyPUTdXkDkgUduboaN'

export const MovieList: FC = () => {
  const { connection } = useConnection()
  const [movies, setMovies] = useState<Movie[]>([])

  useEffect(() => {
    connection.getProgramAccounts(new web3.PublicKey(MOVIE_REVIEW_PROGRAM_ID)).then(async (accounts) => {
      const movies: Movie[] = accounts.map(({ account }) => {
        return Movie.deserialize(account.data)
      })

      setMovies(movies)
    })
  }, [])

  return (
    <div>
      {
        movies.map((movie, i) => <Card key={i} movie={movie} /> )
      }
    </div>
  )
}
```

На цьому етапі ви повинні мати можливість запустити додаток і побачити список відгуків про фільми, отриманих з програми!

Залежно від кількості наданих відгуків, це може зайняти багато часу для завантаження або навіть може призвести до зависання вашого браузера. Але не переживайте — в наступному уроці ми дізнаємося, як здійснювати пагінацію та фільтрацію акаунтів, щоб ви могли більш ефективно завантажувати потрібні дані.

Якщо вам потрібно більше часу для роботи з цим проєктом, щоб комфортно освоїти ці концепції, ознайомтеся з [кодом рішення](https://github.com/Unboxed-Software/solana-movie-frontend/tree/solution-deserialize-account-data), перш ніж продовжити.

# Завдання

Тепер ваша черга побудувати щось самостійно. У минулому уроці ви працювали над програмою Student Intros, щоб серіалізувати дані інструкцій та надіслати нову презентацію в мережу. Тепер настав час отримати та десеріалізувати дані акаунтів програми. Пам'ятайте, що Solana програма, яка підтримує це, знаходиться за адресою `HdE95RSVsdb315jfJtaykXhXY478h53X6okDupVfY9yf`.

![Student Intros frontend](../assets/student-intros-frontend.png)

1. Ви можете побудувати це з нуля або завантажити [стартовий код](https://github.com/Unboxed-Software/solana-student-intros-frontend/tree/solution-serialize-instruction-data).
2. Створіть структуру буфера облікового запису в файлі `StudentIntro.ts`. Дані облікового запису містять:
   1. `initialized` як беззнакове 8-бітове ціле число, що вказує, яку інструкцію виконати (повинно бути 1).
   2. `name` як рядок, що представляє ім'я студента.
   3. `message` як рядок, що представляє повідомлення студента про його подорож із Solana.
3. Створіть статичний метод у файлі `StudentIntro.ts`, який за допомогою структури буфера десеріалізує буфер даних облікового запису в об'єкт `StudentIntro`.
4. У компоненті `StudentIntroList` в `useEffect` отримайте облікові записи програми та десеріалізуйте їхні дані у список об'єктів `StudentIntro`.
5. Замість імітованих даних тепер ви повинні побачити студентські введення з мережі!

Якщо ви застрягли, не соромтесь [перевірити код рішення](https://github.com/Unboxed-Software/solana-student-intros-frontend/tree/solution-deserialize-account-data).

Як завжди, будьте креативними з цими завданнями і розвивайте їх далі, якщо хочете!


## Завершили лабораторну роботу?

Залийте свій код на GitHub і [поділіться своїми враженнями від цього уроку](https://form.typeform.com/to/IPH0UGz7#answers-lesson=9cb89e09-2c97-4185-93b0-c89f7aca7677)!
