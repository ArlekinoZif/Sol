---
назва: Hello World  
завдання:  
- Використати систему модулів Rust  
- Визначити функцію в Rust  
- Пояснити тип `Result`  
- Пояснити точку входу до програми Solana  
- Побудувати та розгорнути базову програму Solana  
- Надіслати транзакцію для виклику нашої програми "Hello, world!"
---

# Стислий виклад

- **Програми** на Solana — це особливий тип акаунтів, які зберігають і виконують логіку інструкцій.
- Програми Solana мають єдину **точку входу** для обробки інструкцій.
- Програма обробляє інструкцію за допомогою **program_id**, списку **accounts** та **instruction_data**, що включені в інструкцію.

# Урок

Здатність Solana виконувати довільний виконуваний код є однією з причин її потужності. Програми Solana, подібно до "смарт-контрактів" в інших блокчейн середовищах, є буквально основою екосистеми Solana. І колекція програм зростає щодня, оскільки розробники та творці вигадують і розгортають нові програми.

Цей урок дасть вам базове введення в написання та розгортання програми Solana за допомогою мови програмування Rust. Щоб уникнути відволікань на налаштування локального середовища розробки, ми будемо використовувати браузерний IDE під назвою Solana Playground.

## Основи Rust

Перед тим як розпочати будувати нашу програму "Hello, world!", давайте спершу ознайомимося з деякими основами Rust. Якщо ви хочете глибше вивчити Rust, ознайомтесь з [книгою про мову Rust](https://doc.rust-lang.org/book/ch00-00-introduction.html).

### Система модулів

Rust організовує код за допомогою системи модулів.

Це включає:

- **Модулі** - Модуль розділяє код на логічні одиниці, щоб забезпечити ізольовані простори імен для організації, області видимості та конфіденційності шляхів.
- **Крейти** - Крейтом є або бібліотека, або виконувана програма. Джерело коду для крейту зазвичай розділене на кілька модулів.
- **Пакети** - Пакет містить колекцію крейтів, а також маніфест файл для вказівки метаданих і залежностей між пакетами.
  
Протягом цього уроку ми зосередимося на використанні крейтів та модулів.

### Шляхи та область видимості

Крейти в Rust містять модулі, що визначають функціональність, яку можна використовувати в кількох проектах. Якщо ми хочемо отримати доступ до елемента в модулі, нам потрібно знати його "шлях" (як при навігації по файловій системі).

Уявіть структуру крейту як дерево, де крейт є основою, а модулі — це гілки, кожна з яких може мати підмодулі або елементи, які є додатковими гілками.

Шлях до певного модуля або елемента — це назва кожного кроку від крейту до цього модуля, де кожен крок відокремлений символом `::`. Наприклад, розглянемо наступну структуру:

1. Базовий крейт — це `solana_program`
2. `solana_program` містить модуль з назвою `account_info`
3. `account_info` містить структуру з назвою `AccountInfo`

Шлях до `AccountInfo` буде `solana_program::account_info::AccountInfo`.

Без використання інших ключових слів, нам потрібно буде звертатися до цього повного шляху, щоб використовувати `AccountInfo` в нашому коді.

Однак за допомогою ключового слова [`use`](https://doc.rust-lang.org/stable/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html) ми можемо привести елемент до області видимості, щоб його можна було повторно використовувати протягом файлу без вказування повного шляху кожного разу. Зазвичай можна побачити серію команд `use` на початку файлу Rust.

```rust
use solana_program::account_info::AccountInfo
```

### Оголошення функцій в Rust

Ми визначаємо функцію в Rust, використовуючи ключове слово `fn`, за яким слідує назва функції та набір круглих дужок.

```rust
fn process_instruction()
```

Ми можемо додати аргументи до нашої функції, вказавши імена змінних і їх відповідні типи даних у дужках.

Rust відомий як "статично типізована" мова, і кожне значення в Rust має певний "тип даних". Це означає, що Rust повинен знати типи всіх змінних під час компіляції. У випадках, коли можливі кілька типів, ми повинні додавати анотацію типу до наших змінних.

У наведеному нижче прикладі ми створюємо функцію з назвою `process_instruction`, яка потребує наступних аргументів:

- `program_id` — повинен мати тип `&Pubkey`
- `accounts` — повинен мати тип `&[AccountInfo]`
- `instruction_data` — повинен мати тип `&[u8]`
  
Зверніть увагу на `&` перед типом для кожного аргументу, що перелічений у функції `process_instruction`. У Rust `&` представляє "посилання" на іншу змінну. Це дозволяє звертатися до деякого значення без того, щоб забирати його власність. "Посилання" гарантує, що воно вказує на дійсне значення певного типу. Дія створення посилання в Rust називається "позичанням" (`borrowing`).

У цьому прикладі, коли функція `process_instruction` викликається, користувач повинен передати значення для необхідних аргументів. Функція `process_instruction` потім посилається на значення, передані користувачем, і гарантує, що кожне значення має правильний тип даних, зазначений у функції `process_instruction`.

Крім того, зверніть увагу на квадратні дужки `[]` навколо `&[AccountInfo]` та `&[u8]`. Це означає, що аргументи `accounts` і `instruction_data` очікують "слайси" типів `AccountInfo` та `u8` відповідно. "Слайс" схожий на масив (колекцію об'єктів одного типу), за винятком того, що довжина не відома під час компіляції. Іншими словами, аргументи `accounts` та `instruction_data` очікують вхідні дані невідомої довжини.

```rust
fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
)
```

Ми можемо змусити наші функції повертати значення, оголосивши тип повернення за допомогою стрілки `->` після функції.

У наведеному прикладі функція `process_instruction` тепер буде повертати значення типу `ProgramResult`. Ми розглянемо це в наступному розділі.

```rust
fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult
```

### Result enum

`Result` — це тип стандартної бібліотеки, який представляє два можливі результати: успіх (`Ok`) або невдача (`Err`). Ми детальніше поговоримо про перелічення (enum) в майбутньому уроці, але ви побачите використання `Ok` пізніше в цьому уроці, тому важливо ознайомитись з основами.

Коли ви використовуєте `Ok` або `Err`, потрібно вказати значення, тип якого визначається контекстом коду. Наприклад, функція, яка вимагає повернення значення типу `Result<String, i64>`, означає, що функція може або повернути `Ok` з вбудованим значенням рядка, або `Err` з вкладеним цілим числом. У цьому прикладі ціле число є кодом помилки, який можна використовувати для відповідного оброблення помилки.

Щоб повернути успішний випадок з рядковим значенням, ви можете зробити наступне:

```rust
Ok(String::from("Success!"));
```

Щоб повернути помилку з цілим числом, ви можете зробити наступне:

```rust
Err(404);
```

## Програми Solana

Згадаємо, що всі дані, збережені в мережі Solana, містяться в акаунтах. Кожен акаунт має свою унікальну адресу, яка використовується для ідентифікації та доступу до даних акаунта. Програми Solana — це просто особливий тип акаунтів Solana, які зберігають та виконують інструкції.

### Solana Program Crate

Для написання програм Solana за допомогою Rust ми використовуємо крейт бібліотеки `solana_program`. Крейт `solana_program` виступає як стандартна бібліотека для програм Solana. Ця стандартна бібліотека містить модулі та макроси, які ми використовуватимемо для розробки наших програм Solana. Якщо ви хочете глибше вивчити крейт `solana_program`, ознайомтесь з [документацією крейту `solana_program`](https://docs.rs/solana-program/latest/solana_program/index.html).

Для базової програми нам потрібно привести до області видимості наступні елементи з крейту `solana_program`:

```rust
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg
};
```

- `AccountInfo` — структура в модулі `account_info`, яка дозволяє нам отримувати інформацію про акаунт
- `entrypoint` — макрос, що оголошує точку входу програми
- `ProgramResult` — тип в модулі `entrypoint`, що повертає або `Result`, або `ProgramError`
- `Pubkey` — структура в модулі `pubkey`, яка дозволяє нам отримувати адреси як публічні ключі
- `msg` — макрос, який дозволяє нам виводити повідомлення в журнал програми

### Точка входу програми Solana

Програми Solana потребують єдиної точки входу для обробки інструкцій програми. Точка входу оголошується за допомогою макросу `entrypoint!`.

Точка входу програми Solana вимагає функцію `process_instruction` з наступними аргументами:

- `program_id` — адреса акаунта, де зберігається програма
- `accounts` — список акаунтів, необхідних для обробки інструкції
- `instruction_data` — серіалізовані дані, специфічні для інструкції

```rust
entrypoint!(process_instruction);

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult;
```

Згадаємо, що акаунти програм Solana зберігають лише логіку для обробки інструкцій. Це означає, що акаунти програм є "тільки для читання" та "безстанними". "Стан" (набір даних), який програма потребує для обробки інструкції, зберігається в акаунтах даних (окремо від акаунтів програм).

Для обробки інструкції акаунти даних, які потрібні для інструкції, повинні бути явно передані в програму через аргумент `accounts`. Будь-які додаткові входи повинні бути передані через аргумент `instruction_data`.

Після виконання програми програма повинна повернути значення типу `ProgramResult`. Цей тип є `Result`, де вкладене значення успішного випадку — це `()`, а вкладене значення випадку помилки — це `ProgramError`. `()` — це порожнє значення, а `ProgramError` — це тип помилки, визначений у крейті `solana_program`.

...і ось вам основи — тепер ви знаєте все, що потрібно для створення програми Solana за допомогою Rust. Тепер давайте попрактикуємося з тим, що ми вивчили до цього часу!

# Лабораторна робота

Ми створимо програму "Hello, World!" за допомогою Solana Playground. Solana Playground — це інструмент, який дозволяє писати та розгортати програми Solana безпосередньо з браузера.

### 1. Налаштування

Відкрийте [Solana Playground](https://beta.solpg.io/). Далі видаліть все в стандартному файлі `lib.rs` та створіть гаманець в Playground.

![Gif Solana Playground Create Wallet](../assets/hello-world-create-wallet.gif)

### 2. Solana Program Crate

Спочатку давайте приведемо до області видимості все, що нам потрібно з крейту `solana_program`.

```rust
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg
};
```

Далі налаштуємо точку входу до нашої програми за допомогою макросу `entrypoint!` і створимо функцію `process_instruction`. Макрос `msg!` дозволяє нам вивести "Hello, world!" в журнал програми під час виклику програми.

### 3. Точка входу

```rust
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8]
) -> ProgramResult{
    msg!("Hello, world!");

    Ok(())
}
```

Вся програма "Hello, world!" виглядатиме ось так:

```rust
use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg
};

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8]
) -> ProgramResult{
    msg!("Hello, world!");

    Ok(())
}
```

### 4. Створення та розгортання

Тепер давайте створимо та розгорнемо нашу програму за допомогою Solana Playground.

![Gif Solana Playground Build and Deploy](../assets/hello-world-build-deploy.gif)

### 5. Виклик програми

Нарешті, давайте викликаємо нашу програму з боку клієнта. Основна мета цього уроку — створити нашу програму Solana, тому ми вже підготували [код клієнта для виклику нашої програми "Hello, world!"](https://github.com/Unboxed-Software/solana-hello-world-client), який ви можете завантажити.

Наданий код містить допоміжну функцію `sayHello`, яка будує та надсилає нашу транзакцію. Потім ми викликаємо `sayHello` в головній функції та виводимо URL Solana Explorer, щоб переглянути деталі нашої транзакції в браузері.

Відкрийте файл `index.ts`, і ви побачите змінну з іменем `programId`. Оновіть її, вказавши ID програми “Hello, world!”, яку ви щойно розгорнули за допомогою Solana Playground.

```tsx
let programId = new web3.PublicKey("<YOUR_PROGRAM_ID>");
```

Ви можете знайти ID програми на Solana Playground, орієнтуючись на зображення нижче.

![Gif Solana Playground Program ID](../assets/hello-world-program-id.gif)

Next, install the Node modules with `npm i`.

Now, go ahead and run `npm start`. This command will:
1. Generate a new keypair and create a `.env` file if one does not already exist
2. Airdrop devnet SOL
3. Invoke the “Hello, world!” program
4. Output the transaction URL to view on Solana Explorer

Скопіюйте URL транзакції, який виведено в консолі, і вставте його у ваш браузер. Прокрутіть сторінку вниз, щоб побачити “Hello, world!” під "Program Instruction Logs".

![Screenshot Solana Explorer Program Log](../assets/hello-world-program-log.png)

Вітаємо, ви щойно успішно створили та розгорнули програму Solana!

# Завдання

Тепер ваша черга створити щось самостійно. Оскільки ми починаємо з дуже простих програм, ваша програма виглядатиме майже так само, як та, яку ми тільки що створили. Це корисно, щоб досягти того рівня, коли ви можете написати програму з нуля без посилання на попередній код, тому намагайтеся не копіювати та вставляти тут.

1. Напишіть нову програму, яка використовує макрос `msg!` для виведення власного повідомлення в журнал програми.
2. Створіть і розгорніть вашу програму так, як ми робили це в лабораторії.
3. Викликайте щойно розгорнуту програму та використовуйте Solana Explorer, щоб перевірити, чи було виведене ваше повідомлення в журналі програми.

Як завжди, будьте креативними в цих завданнях і розширюйте їх за межі базових інструкцій, якщо хочете — і насолоджуйтеся процесом!

## Завершили лабораторну роботу?

Завантажте ваш код на GitHub та [поділіться вашими враженнями від цього уроку](https://form.typeform.com/to/IPH0UGz7#answers-lesson=5b56c69c-1490-46e4-850f-a7e37bbd79c2)!
