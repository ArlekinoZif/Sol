---
заголовок: Створення базової програми, Частина 1 - Обробка даних інструкцій  
цілі:  
- Призначати змінні та незмінні перемінні в Rust  
- Створювати та використовувати структури та переліки (enums) у Rust  
- Використовувати оператори `match` у Rust  
- Додавати імплементації до типів у Rust  
- Десеріалізувати дані інструкцій у типи даних Rust  
- Виконувати різну програмну логіку для різних типів інструкцій  
- Пояснити структуру смарт-контракту на Solana  
---

# Короткий огляд

- Більшість програм підтримують **кілька окремих інструкцій** — ви визначаєте ці інструкції та дані, які мають їх супроводжувати, під час написання програми.  
- У Rust часто використовуються **переліки (enums)** для представлення окремих інструкцій програми.  
- Ви можете використовувати бібліотеку `borsh` і атрибут `derive` для забезпечення функціональності десеріалізації та серіалізації Borsh для структур Rust.  
- Вирази `match` у Rust допомагають створювати умовні шляхи виконання коду на основі наданої інструкції.  

# Урок

Одним із базових елементів програми Solana є логіка обробки даних інструкції. Більшість програм підтримують кілька взаємопов’язаних функцій і використовують відмінності в даних інструкції для визначення, який шлях виконання коду слід застосувати. Наприклад, два різні формати даних в інструкціях можуть представляти інструкції для створення нового елемента даних або для його видалення.

Оскільки дані інструкції передаються до точки входу вашої програми у вигляді масиву байтів, зазвичай створюється тип даних Rust для представлення інструкцій у більш зручному форматі для використання в коді. У цьому уроці буде показано, як налаштувати такий тип, як десеріалізувати дані інструкції у цей формат і як виконати код на основі інструкції, переданої до точки входу програми.

## Основи Rust 

Перш ніж заглиблюватися в особливості базової програми Solana, давайте поговоримо про основи Rust, які ми використовуватимемо протягом цього уроку.

### ### Змінні

Присвоєння змінних у Rust виконується за допомогою ключового слова `let`.

```rust
let age = 33;
```

Змінні в Rust за замовчуванням є незмінними, тобто значення змінної не можна змінити після його встановлення. Щоб створити змінну, значення якої ми хочемо змінити в майбутньому, використовуємо ключове слово `mut`. Визначення змінної з цим ключовим словом означає, що значення, яке в ній зберігається, може змінюватися.

```rust
// compiler will throw error
let age = 33;
age = 34;

// this is allowed
let mut mutable_age = 33;
mutable_age = 34;
```

Компилятор Rust гарантує, що незмінні змінні дійсно не можуть змінюватися, тому вам не потрібно відслідковувати це самостійно. Це робить ваш код легшим для розуміння та спрощує процес налагодження.

### ### Структури (Structs)

Структура (struct) — це користувацький тип даних, який дозволяє об'єднати та назвати декілька пов'язаних значень, що утворюють осмислену групу. Кожен елемент даних у структурі може мати різні типи, і кожен має пов'язане з ним ім'я. Ці елементи даних називаються **полями** (fields). Вони поводяться подібно до властивостей у інших мовах програмування.

```rust
struct User {
    active: bool,
    email: String,
    age: u64
}
```

Щоб використовувати структуру після її визначення, ми створюємо екземпляр цієї структури, вказуючи конкретні значення для кожного з її полів.

```rust
let mut user1 = User {
    active: true,
    email: String::from("test@test.com"),
    age: 36
};
```

Щоб отримати або встановити конкретне значення з структури, ми використовуємо нотацію крапки (dot notation).

```rust
user1.age = 37;
```

### Перерахування (Enumerations)

Перерахування (або Enums) — це структура даних, яка дозволяє визначити тип, перераховуючи його можливі варіанти. Приклад перерахування може виглядати так:

```rust
enum LightStatus {
    On,
    Off
}
```

Перерахування `LightStatus` має два можливі варіанти в цій ситуації: це або `On`, або `Off`.

Також можна вбудовувати значення у варіанти перерахування, подібно до додавання полів до структури.

```rust
enum LightStatus {
    On {
        color: String
    },
    Off
}

let light_status = LightStatus::On { color: String::from("red") };
```

У цьому прикладі, встановлення змінної до варіанту `On` перерахування `LightStatus` також вимагає встановлення значення для `color`.

### Оператори Match

Оператори `match` дуже схожі на операторів `switch` у C/C++. Оператор `match` дозволяє порівнювати значення з серією шаблонів і виконувати код залежно від того, який шаблон відповідає значенню. Шаблони можуть складатися з літеральних значень, змінних імен, шаблонів значень (wildcards) та іншого. Оператор `match` має охоплювати всі можливі варіанти, інакше код не скомпілюється.

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25
    }
}
```

### Implementations

Ключове слово `impl` використовується в Rust для визначення застосування типу. В межах реалізації можна визначати функції та константи для конкретного типу.

```rust
struct Example {
    number: i32
}

impl Example {
    fn boo() {
        println!("boo! Example::boo() was called!");
    }

    fn answer(&mut self) {
        self.number += 42;
    }

    fn get_number(&self) -> i32 {
        self.number
    }
}
```

Функція `boo` тут може бути викликана тільки на самому типі, а не на його екземплярі, ось так:

```rust
Example::boo();
```

Тим часом, `answer` вимагає змінного екземпляра `Example` і може бути викликана за допомогою синтаксису крапки:

```rust
let mut example = Example { number: 3 };
example.answer();
```

### Трейти та атрибути

Ви не будете створювати свої власні трейти або атрибути на цьому етапі, тому ми не будемо детально на цьому зупинятися. Однак ви будете використовувати атрибут макроса `derive` та деякі трейти, надані бібліотекою `borsh`, тому важливо мати загальне розуміння кожного з них.

**Трейти** описують абстрактний інтерфейс, який можуть реалізовувати типи. Якщо трейт визначає функцію `bark()`, і тип приймає цей трейт, то тип повинен реалізувати функцію `bark()`.

[**Атрибути**](https://doc.rust-lang.org/rust-by-example/attribute.html) додають метадані до типу і можуть використовуватись для різних цілей.

Коли ви додаєте атрибут [`derive`](https://doc.rust-lang.org/rust-by-example/trait/derive.html) до типу і вказуєте один або більше підтримуваних трейтів, то під капотом генерується код для автоматичної реалізації цих трейтів для цього типу. Ми надамо конкретний приклад цього незабаром.

## Інструкції як тип даних у Rust

Тепер, коли ми охопили основи Rust, давайте застосуємо їх до програм Solana.

Часто програми мають більше ніж одну функцію. Наприклад, у вас може бути програма, яка діє як бекенд для програми для нотаток. Припустимо, ця програма приймає інструкції для створення нової нотатки, оновлення існуючої нотатки та видалення існуючої нотатки.

Оскільки інструкції мають чітко визначені типи, вони зазвичай добре підходять для використання в якості типу даних enum.

```rust
enum NoteInstruction {
    CreateNote {
        title: String,
        body: String,
        id: u64
    },
    UpdateNote {
        title: String,
        body: String,
        id: u64
    },
    DeleteNote {
        id: u64
    }
}
```

Зверніть увагу, що кожен варіант enum `NoteInstruction` має вбудовані дані, які використовуватимуться програмою для виконання завдань створення, оновлення та видалення нотатки відповідно.

## Десеріалізація даних інструкцій

Дані інструкції передаються програмі у вигляді масиву байтів, тому вам потрібен спосіб детерміновано перетворити цей масив у екземпляр enum інструкції.

У попередніх блоках ми використовували Borsh для серіалізації та десеріалізації на стороні клієнта. Для використання Borsh на стороні програми ми використовуємо crate `borsh`. Цей crate надає трейти `BorshDeserialize` та `BorshSerialize`, які можна застосувати до ваших типів за допомогою атрибута `derive`.

Щоб зробити десеріалізацію даних простою, можна створити структуру, яка представлятиме дані, і використати атрибут `derive`, щоб застосувати трейт `BorshDeserialize` до цієї структури. Це реалізує методи, визначені в `BorshDeserialize`, включаючи метод `try_from_slice`, який ми будемо використовувати для десеріалізації даних інструкції.

Не забувайте, що сама структура повинна відповідати структурі даних у масиві байтів.

```rust
#[derive(BorshDeserialize)]
struct NoteInstructionPayload {
    id: u64,
    title: String,
    body: String
}
```

Після створення цієї структури можна реалізувати ваш енум інструкцій (instruction enum), щоб обробляти логіку, пов'язану з десеріалізацією даних інструкції. Зазвичай це робиться у функції під назвою `unpack`, яка приймає дані інструкції як аргумент і повертає відповідний екземпляр енуму з десеріалізованими даними.

За стандартом, програму структурують таким чином, щоб вона очікувала, що перший байт (або інша фіксована кількість байтів) буде ідентифікатором, який визначає, яку інструкцію повинна виконати програма. Це може бути ціле число або рядковий ідентифікатор. У цьому прикладі ми використовуємо перший байт і зіставляємо цілі числа 0, 1 і 2 з інструкціями `create`, `update` і `delete`, відповідно.

```rust
impl NoteInstruction {
    // Unpack inbound buffer to associated Instruction
    // The expected format for input is a Borsh serialized vector
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Take the first byte as the variant to
        // determine which instruction to execute
        let (&variant, rest) = input.split_first().ok_or(ProgramError::InvalidInstructionData)?;
        // Use the temporary payload struct to deserialize
        let payload = NoteInstructionPayload::try_from_slice(rest).unwrap();
        // Match the variant to determine which data struct is expected by
        // the function and return the TestStruct or an error
        Ok(match variant {
            0 => Self::CreateNote {
                title: payload.title,
                body: payload.body,
                id: payload.id
            },
            1 => Self::UpdateNote {
                title: payload.title,
                body: payload.body,
                id: payload.id
            },
            2 => Self::DeleteNote {
                id: payload.id
            },
            _ => return Err(ProgramError::InvalidInstructionData)
        })
    }
}
```

У цьому прикладі багато деталей, тому давайте розберемо все поетапно:

1. Ця функція починає з використання функції `split_first` для параметра `input`, щоб отримати кортеж. Перший елемент, `variant`, — це перший байт з байтового масиву, а другий елемент, `rest`, — це залишок байтового масиву.  
2. Далі функція використовує метод `try_from_slice` для `NoteInstructionPayload`, щоб десеріалізувати залишок байтового масиву у екземпляр `NoteInstructionPayload`, який називається `payload`.  
3. Нарешті, функція використовує оператор `match` для `variant`, щоб створити й повернути відповідний екземпляр перерахування (enum), використовуючи інформацію з `payload`.  

Зверніть увагу, що у цій функції використовується синтаксис Rust, який ми ще не пояснювали. Функції `ok_or` та `unwrap` використовуються для обробки помилок, і їх буде детально розглянуто в іншому уроці.

## Логіка програми

Маючи спосіб десеріалізації даних інструкції у користувацький тип Rust, ви можете використовувати відповідний потік управління, щоб виконувати різні гілки коду у вашій програмі залежно від того, яка інструкція передається у точку входу вашої програми.

```rust
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8]
) -> ProgramResult {
    // Call unpack to deserialize instruction_data
    let instruction = NoteInstruction::unpack(instruction_data)?;
    // Match the returned data struct to what you expect
    match instruction {
        NoteInstruction::CreateNote { title, body, id } => {
            // Execute program code to create a note
        },
        NoteInstruction::UpdateNote { title, body, id } => {
            // Execute program code to update a note
        },
        NoteInstruction::DeleteNote { id } => {
            // Execute program code to delete a note
        }
    }
}
```

Для простих програм, у яких є лише одна або дві інструкції для виконання, допустимо написати логіку всередині оператора `match`. У програмах з багатьма різними інструкціями ваш код буде значно зрозумілішим, якщо логіка для кожної інструкції буде написана у окремій функції та просто викликатиметься зсередини оператора `match`.

## Структура файлів програми

Програма з уроку [Hello World](hello-world-program) була досить простою, щоб уміститися в одному файлі. Але зі зростанням складності програми важливо підтримувати структуру проєкту, яка залишатиметься зрозумілою та розширюваною. Це включає інкапсуляцію коду у функції та структури даних, як ми вже робили раніше. Але це також передбачає групування пов’язаного коду у окремі файли.

Наприклад, значна частина коду, який ми розглядали до цього моменту, стосується визначення та десеріалізації інструкцій. Цей код має бути у власному файлі, а не в тому ж файлі, що й точка входу. Завдяки цьому ми матимемо два файли: один із точкою входу програми, а інший із кодом для роботи з інструкціями.

- **lib.rs**
- **instruction.rs**

Коли ви почнете розділяти вашу програму таким чином, вам потрібно буде переконатися, що всі файли зареєстровані в одному центральному місці. Ми будемо робити це у файлі `lib.rs`. **Ви повинні зареєструвати кожен файл вашої програми таким чином.**

```rust
// This would be inside lib.rs
pub mod instruction;
```

Крім того, якщо ви хочете, щоб будь-які заяви були доступні через оператори `use` в інших файлах, вони повинні бути позначені ключовим словом `pub`:

```rust
pub enum NoteInstruction { ... }
```

# Лабораторна робота

У лабораторній роботі цього уроку ми будемо будувати першу частину програми для огляду фільмів, з якою ми працювали в Модулі 1. Ця програма зберігає огляди фільмів.

Зараз ми зосередимося на десеріалізації даних інструкцій. Наступний урок буде присвячений другій частині цієї програми.

### 1. Точка входу

Ми знову використовуватимемо [Solana Playground](https://beta.solpg.io/) для створення цієї програми. Solana Playground зберігає стан у вашому браузері, тому все, що ви робили в попередньому уроці, може залишитися. Якщо це так, давайте очистимо все в поточному файлі `lib.rs`.

Всередині файлу `lib.rs` ми підключимо наступні бібліотеки (crates) та визначимо точку входу до програми за допомогою макросу `entrypoint`.

```rust
use solana_program::{
    entrypoint,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg,
    account_info::AccountInfo,
};

// Entry point is a function call process_instruction
entrypoint!(process_instruction);

// Inside lib.rs
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8]
) -> ProgramResult {

    Ok(())
}
```

### 2. Десеріалізація даних інструкції

Перш ніж продовжити з логікою обробника, ми повинні визначити інструкції та реалізувати функцію десеріалізації.

Для зручності читання давайте створимо новий файл під назвою `instruction.rs`. Всередині цього файлу додайте оператори `use` для `BorshDeserialize` та `ProgramError`, а потім створіть перерахування (enum) `MovieInstruction` з варіантом `AddMovieReview`. Цей варіант має включати значення для `title`, `rating` та `description`.

```rust
use borsh::{BorshDeserialize};
use solana_program::{program_error::ProgramError};

pub enum MovieInstruction {
    AddMovieReview {
        title: String,
        rating: u8,
        description: String
    }
}
```

Далі визначимо структуру `MovieReviewPayload`. Вона буде виконувати роль проміжного типу для десеріалізації, тому вона повинна використовувати макрос атрибуту `derive` для надання стандартної реалізації для трейту `BorshDeserialize`.

```rust
#[derive(BorshDeserialize)]
struct MovieReviewPayload {
    title: String,
    rating: u8,
    description: String
}
```

Останнім кроком буде створення реалізації для перерахування `MovieInstruction`, яке визначає та реалізує функцію `unpack`, що приймає байтовий масив як аргумент і повертає тип `Result`. Ця функція повинна:

1. Використовувати функцію `split_first` для розділення першого байту масиву від решти масиву.
2. Десеріалізувати решту масиву в екземпляр `MovieReviewPayload`.
3. Використовувати оператор `match`, щоб повернути варіант `AddMovieReview` перерахування `MovieInstruction`, якщо перший байт масиву дорівнює 0, або повернути помилку програми в іншому випадку.

```rust
impl MovieInstruction {
    // Unpack inbound buffer to associated Instruction
    // The expected format for input is a Borsh serialized vector
    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
        // Split the first byte of data
        let (&variant, rest) = input.split_first().ok_or(ProgramError::InvalidInstructionData)?;
        // `try_from_slice` is one of the implementations from the BorshDeserialization trait
        // Deserializes instruction byte data into the payload struct
        let payload = MovieReviewPayload::try_from_slice(rest).unwrap();
        // Match the first byte and return the AddMovieReview struct
        Ok(match variant {
            0 => Self::AddMovieReview {
                title: payload.title,
                rating: payload.rating,
                description: payload.description },
            _ => return Err(ProgramError::InvalidInstructionData)
        })
    }
}
```

### 3. Логіка програми

Оскільки десеріалізація інструкцій завершена, ми можемо повернутися до файлу `lib.rs`, щоб реалізувати частину нашої програми.

Не забувайте, що оскільки ми додали код в інший файл, нам потрібно зареєструвати його у файлі `lib.rs` за допомогою `pub mod instruction;`. Потім ми можемо додати оператор `use`, щоб зробити тип `MovieInstruction` доступним в межах цього файлу.

```rust
pub mod instruction;
use instruction::{MovieInstruction};
```

Далі давайте визначимо нову функцію `add_movie_review`, яка прийматиме аргументи: `program_id`, `accounts`, `title`, `rating` та `description`. Функція повинна також повертати екземпляр типу `ProgramResult`. Всередині цієї функції на даному етапі просто виведемо значення на лог, а решту реалізації ми розглянемо в наступному уроці.

```rust
pub fn add_movie_review(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    title: String,
    rating: u8,
    description: String
) -> ProgramResult {

    // Logging instruction data that was passed in
    msg!("Adding movie review...");
    msg!("Title: {}", title);
    msg!("Rating: {}", rating);
    msg!("Description: {}", description);

    Ok(())
}
```

Коли це буде зроблено, ми зможемо викликати функцію `add_movie_review` з функції `process_instruction` (функція, яку ми встановили як точку входу). Щоб передати всі необхідні аргументи в функцію, спочатку потрібно викликати функцію `unpack`, яку ми створили для `MovieInstruction`, а потім використовувати оператор `match`, щоб переконатися, що отримана інструкція є варіантом `AddMovieReview`.

```rust
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8]
) -> ProgramResult {
    // Unpack called
    let instruction = MovieInstruction::unpack(instruction_data)?;
    // Match against the data struct returned into `instruction` variable
    match instruction {
        MovieInstruction::AddMovieReview { title, rating, description } => {
            // Make a call to `add_move_review` function
            add_movie_review(program_id, accounts, title, rating, description)
        }
    }
}
```

І ось так, ваша програма повинна бути достатньо функціональною,  щоб реєструвати дані інструкцій, що передаються при відправленні транзакції!

Побудуйте та розгорніть вашу програму з Solana Program, як це було у попередньому уроці. Якщо ви не змінювали ID програми після проходження минулого уроку, програма буде автоматично розгорнута на той самий ID. Якщо ви хочете, щоб програма мала окрему адресу, ви можете згенерувати новий ID програми з Playground перед розгортанням.

Ви можете протестувати вашу програму, подаючи транзакцію з правильними даними інструкції. Для цього використовуйте [цей скрипт](https://github.com/Unboxed-Software/solana-movie-client) або [фронтенд](https://github.com/Unboxed-Software/solana-movie-frontend), який ми створювали в уроці [Серіалізація даних кастомних інструкцій](serialize-instruction-data). В обох випадках переконайтеся, що ви скопіювали та вставили ID програми в потрібну частину коду, щоб протестувати правильну програму.

Якщо вам потрібно більше часу на цю лабораторну роботу перед тим, як перейти до наступного етапу, будь ласка, не поспішайте! Ви також можете переглянути [код рішення програми](https://beta.solpg.io/62aa9ba3b5e36a8f6716d45b), якщо застрягнете.

# Виклик

Для цього уроку спробуйте відтворити програму *Student Intro* з модуля 1. Згадайте, що ми створили фронтенд-додаток, який дозволяє студентам представляти себе! Програма приймає ім'я користувача та коротке повідомлення як `instruction_data` і створює акаунт для збереження цих даних на блокчейні.

Використовуючи те, що ви вивчили в цьому уроці, побудуйте програму *Student Intro* так, щоб ви могли вивести в логи програми ім'я та повідомлення, надані користувачем, коли програма викликається.

Ви можете протестувати вашу програму, побудувавши [цей фронтенд](https://github.com/Unboxed-Software/solana-student-intros-frontend/tree/solution-serialize-instruction-data), який ми створювали в уроці [Серіалізація кастомних інструкцій](serialize-instruction-data), а потім перевірити логи програми в Solana Explorer. Не забудьте замінити ID програми в коді фронтенду на той, який ви розгорнули.

Спробуйте зробити це самостійно! Але якщо ви застрягли, не соромтеся звернутися до [коду рішення](https://beta.solpg.io/62b0ce53f6273245aca4f5b0).

## Завершили лабораторну роботу?

Завантажте свій код на GitHub та [поділіться своєю думкою про цей урок](https://form.typeform.com/to/IPH0UGz7#answers-lesson=74a157dc-01a7-4b08-9a5f-27aa51a4346c)!
